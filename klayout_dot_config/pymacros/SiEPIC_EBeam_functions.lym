<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>SiEPIC EBeam PDK functions</description>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># Python script
# SiEPIC_EBeam_functions

"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski (c) 2015

This Python file implements various functions for the SiEPIC_EBeam_PDK 


NOTE: after changing the code, the macro needs to be rerun to install the new
implementation. The macro is also set to "auto run" these definitions and functions 
when KLayout is run.

Version history:

Lukas Chrostowski           2015/11/13
 - SiEPIC-EBeam-PDK Layer table 
 - Clear errors function
 - delete_extra_top_cells
 - function to delete extra cells
    def delete_extra_top_cells():
 - find all the automated measurement labels

Lukas Chrostowski           2015/11/15
 - fix for Python 3.4: print("xxx")
 - moved some functions from SiEPIC_EBeam_Verification, so they are accessible elsewhere.

Lukas Chrostowski           2015/11/16
 - fixes for component pin_type = Optical IO / FbrTgt being incorrectly handled; added Optical_pin.pin_type

Lukas Chrostowski           2015/11/17
 - debugging &amp; fixing Verification problems
   - Optical_*.n replaced with .idx, and starting from 0. -1 for undefined/disconnected.
   - added functions for listing:
     print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)
     print_Optical_components(optical_components)
     print_Optical_waveguides(optical_waveguides)
     print_Optical_pins(optical_pins)
     print_Optical_nets(optical_nets)
 - improvements to Spice output, engineering format
 - extensive testing of verification, including large test layout
 - several floating point issues

Lukas Chrostowski           2015/11/18
 - removed need for numpy.array
  
Lukas Chrostowski           2015/11/19
 - finding the laser and detectors in the layout
 - generating a Spice netlist including Optical Network Analyzer; ready for Lumerical INTERCONNECT
 - Added Python 2 &amp; 3 compatibility for iter.next() vs. next(iter)

Lukas Chrostowski           2015/11/21
 - bug fix in points_mult, that argument in the function was being modified. needed to copy it.
 
Lukas Chrostowski           2015/12/9
 - .index() is a list method; replaced Optical_*.idx with .idx
 
 - Working towards merging ROUND_PATH and Waveguide_Route, into Waveguide_Route.  
   Provide option for netlist generation (simple, advanced).
   need to identify the Inst for waveguide, in find_all_waveguides, and save in optical_waveguides
"""

SiEPIC_Version = '0.1.6'

import pya
import math
import string

try:
  import numpy
except ImportError:
  #import numpy
  print("no numpy")
  MODULE_NUMPY = False



# SiEPIC-EBeam-PDK Layers:
LayerSi = pya.LayerInfo(1, 0)
LayerSiSP = pya.LayerInfo(31, 0)
LayerText = pya.LayerInfo(10, 0)
LayerPinRec = pya.LayerInfo(69, 0)
LayerDevRec = pya.LayerInfo(68, 0)
LayerFbrTgt = pya.LayerInfo(81, 0)
LayerError = pya.LayerInfo(999,0)
LayerINTERCONNECT = pya.LayerInfo(733,0)


# define the types of waveguides we have, as defined in Path_to_Waveguide
#Waveguide_Types = "ROUND_PATH Waveguide_Route Waveguide_Route_simple"
#Waveguide_Types = ["ROUND_PATH", "Waveguide_Route", "Waveguide_Route_simple"]
Waveguide_Types = ["ROUND_PATH", "Waveguide_Route"]

# Netlist extraction will merge straight+bend sections into waveguide (1), 
# or extract each bend, straight section, etc. (0)
WAVEGUIDE_extract_simple = 1



# Determine whether we have Python 2 or Python 3
import sys
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3    

if PY3:
    # Python 3 code
    pass
else:
    # Python 2 code
    pass

try:
  advance_iterator = next
except NameError:
  def advance_iterator(it):
    return it.next()




# definition of classes for Verification, Waveguide making, Waveguide Healing
# one for each instance of the components
class Optical_component:
    def __init__(self, idx, component, instance, x, y, flip, rotate, library, params):
        self.idx = idx             # component index, should be unique, 0, 1, 2, ...
        self.component = component # which component (name) this pin belongs to
        self.instance = instance   # which component (instance) this pin belongs to
        self.x = x                 # instance location
        self.y = y                 # instance location
        self.flip = flip           # instance flip, True / False
        self.rotate = rotate       # instance rotation, 0, 90, 180, 270
        self.library = library     # compact model library
        self.nets = []             # nets connected to component
        self.npins = 0             # number of pin
        self.pins = []             # an array of all the pins
        self.params = params       # Spice parameters

def print_Optical_components(optical_components):
  print("Optical_components:")
  for o in optical_components:
    print("#%s: %s / %s, (%s, %s), nets %s, npins %s, pins %s" %\
        (o.idx, o.component, o.instance, o.x, o.y, o.nets, o.npins, o.pins) )
        
# definition for the optical waveguide class
class Optical_waveguide:
    def __init__(self, idx, points, radius, length, wg_type, num_points, wg_width, bend_pts):
        self.idx = idx            # waveguide index, should be unique, 0, 1, 2, ...
        self.points = points      # array of vertices, in database units
        self.radius = radius      # radius, in microns
        self.length = length      # length, in microns
        self.wg_type = wg_type    # wg_type: 0: path, 1: ROUND_PATH
        self.num_points = num_points # number of vertices in the path
        self.wg_width = wg_width  # waveguide width
        self.bend_pts = bend_pts  # number of points in a bend, per circle
        self.net1 = -1            # nets; one at each end of the waveguide
        self.net2 = -1            # nets; one at each end of the waveguide
        self.inst = 0             # class Instance for the waveguide cell instance
        self.component = "ebeam_wg_integral_1550"  # comprehensive waveguide model (regular and MC simulations)
#        self.component = "ebeam_wg_strip_1550"  # waveguide model name
        self.library = "Design kits/ebeam_v1.2" # compact model library
#        if 'SIMULATION' in globals():
#          if SIMULATION == 2:
#            self.component = "ebeam_wg_integral_1550"  # Monte Carlo waveguide model name

def print_Optical_waveguides(optical_waveguides):
  print("Optical_waveguides:")
  for o in optical_waveguides:
    print("#%s: length %s, type %s, net1: %s, net2: %s, points: %s" %\
        (o.idx, o.length, o.wg_type, o.net1, o.net2, o.points) )

class Optical_pin:
    def __init__(self, idx, points, component_idx, x, y, pin_type, pin_name):
        self.idx = idx                  # pin number, index, should be unique, 0, 1, 2, ...
        self.points = points            # array of vertices, in database units
        self.component_idx = component_idx  # which component index this pin belongs to
        self.net = -1                    # which net this pin is connected to
        self.x = x                      # x coordinate, in database units
        self.y = y                      # y coordinate, in database units
        self.pin_type = pin_type        # pin type: 0 = waveguide, 1 = component, 2 = opticalIO
        self.pin_name = pin_name        # label read from the cell layout (PinRec text)

def print_Optical_pins(optical_pins):
  print("Optical_pins:")
  for o in optical_pins:
    if o.pin_type == 1:
      points = o.points
    else:
      points = "..."
    print("#%s: component_idx %s, pin_name %s, pin_type %s, net: %s, (%s, %s), points: %s" %\
        (o.idx, o.component_idx, o.pin_name, o.pin_type, o.net, o.x, o.y, points) )

class Optical_net:
    def __init__(self, idx, pin1_type, pin1_n, pin2_type, pin2_n):
        self.idx = idx                  # net number, index, should be unique, 0, 1, 2, ...
        # an optical net can only connect to two pins. 
        # the pin variables point to either Optical_waveguide or Optical_component classes
        self.pin1_type = pin1_type      # pin type: 0 = waveguide, 1 = component, 2 = opticalIO
        self.pin1_n = pin1_n            # pin n: component or waveguide index
        self.pin2_type = pin2_type
        self.pin2_n = pin2_n

def print_Optical_nets(optical_nets):
  print("Optical_nets:")
  for o in optical_nets:
    if o.pin1_type != 0:
      name1 = optical_components[optical_pins[o.pin1_n].component_idx].component
#      name1 = optical_components[o.pin1_n].component
    else:
      name1 = 'waveguide'
    if o.pin2_type != 0:
      name2 = optical_components[optical_pins[o.pin2_n].component_idx].component
#      name2 = optical_components[o.pin2_n].component
    else:
      name2 = 'waveguide'
    print("#%s: pin1: %s (%s) pin_type1: %s; pin2: %s (%s) pin_type2: %s" %\
        (o.idx, o.pin1_n, name1, o.pin1_type, o.pin2_n, name2, o.pin2_type) )

def print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets):
  print_Optical_components(optical_components)
  print_Optical_waveguides(optical_waveguides)
  print_Optical_pins(optical_pins)
  print_Optical_nets(optical_nets)

class Layout_error:
    # for keeeping track of layout errors
    n = 0
    def __init__(self, text, x, y):
        Layout_error.n += 1
        self.text = text              # error text
        self.x = x                    # error location
        self.y = y                    # error location

def reset_Optical_classes():
  Layout_error.n = 0

# multiply an array of points by a constant
def points_mult(dpoints1, mult):
  # create a new empty list.  Otherwise, this function would modify the original list
  # http://stackoverflow.com/questions/240178/python-list-of-lists-changes-reflected-across-sublists-unexpectedly
  newlist = [[0]*2 for n in range(len(dpoints1))] 
  if MODULE_NUMPY:
    return numpy.array(dpoints1)*mult
  else:
    for i in range(0,2):
      for j in range(0,len(dpoints1)):
        newlist[j][i] = dpoints1[j][i]*mult
    return newlist

# calculate the mean in (x,y) for an array of points
def xy_mean_mult(dpoints,dbu):
  if MODULE_NUMPY:
    x = numpy.array(dpoints)[:,0].mean()*dbu
    y = numpy.array(dpoints)[:,1].mean()*dbu
  else:
    x=0
    y=0
    for i in range(0,len(dpoints)):
      x += dpoints[i][0]
      y += dpoints[i][1]
    x = x / len(dpoints) * dbu
    y = y / len(dpoints) * dbu
  return x,y


# Clear the error markers generated by SiEPIC_EBeam_Verification
def clear_ErrorLayer(topcell, LayerErrorN):
  iter1 = topcell.begin_shapes_rec(LayerErrorN)
  
  i=0
  while not(iter1.at_end()):
    if iter1.shape().is_path() | iter1.shape().is_box():
      i+=1
      iter1.shape().delete()
    iter1.next()  
  print("*** Deleted %s errors." % i)



import string
def find_automated_measurement_labels(topcell, LayerTextN):
  # example usage:
  # topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
  # LayerText = pya.LayerInfo(10, 0)
  # LayerTextN = topcell.layout().layer(LayerText)
  # find_automated_measurement_labels(topcell, LayerTextN)
  t = ''
  dbu = topcell.layout().dbu
  iter = topcell.begin_shapes_rec(LayerTextN)
  i=0
  while not(iter.at_end()):
    if iter.shape().is_text():
      text = iter.shape().text
      if text.string.find("opt_in") &gt; -1:
        i+=1
        text2 = iter.shape().text.transformed(iter.itrans())
        t += "label: %s, location: (%s, %s) &lt;br&gt;" %(text.string, text2.x*dbu, text2.y*dbu )
    iter.next()
  t += "&lt;br&gt;*** Number of automated measurement labels: %s.&lt;br&gt;" % i
  return t

  
def find_all_components(cell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN):
  # function to traverse the entire layout hierarchy and find all the components
  # returns list of components, location, orientation
  # use the DevRec shapes.  One DevRec shape per component.
  
  # Find all the DevRec shapes; identify the component it belongs; record the instance info as an Optical_component 
  # for each component instance, also find the Pins and Fibre ports.
  
  # Use the pin names on layer PinRec to sort the pins in alphabetical order
  #   Requires that a text label be in PinRec layer, co-linear inside the PinRec path.
  # sorting the pins uses the Pin_info class:
  class Pin_info:
    def __init__(self, pin_text, pin_x, pin_y):
      self.pin_text = pin_text
      self.pin_x = pin_x
      self.pin_y = pin_y


  # Find all the DevRec shapes
  iter1 = cell.begin_shapes_rec(LayerDevRecN)
  i=0
  while not(iter1.at_end()):
    i+=1
    subcell = iter1.cell()                     # cell (component) to which this shape belongs
    component = subcell.basic_name()   # name library component
    instance = subcell.name      
    subcell.name                # name of the cell; for PCells, different from basic_name
    found_component = False
    # DevRec must be either a Box or a Polygon:
    if iter1.shape().is_box():
      box= iter1.shape().box.transformed(iter1.itrans())
      print("%s: DevRec in cell {%s}, box -- %s; %s"   % (i, subcell.basic_name(), box.p1, box.p2) )
      found_component = True
    if iter1.shape().is_polygon():
      polygon = iter1.shape().polygon.transformed(iter1.itrans())
      print("%s: DevRec in cell {%s}, polygon -- %s"   % (i, subcell.basic_name(), polygon))
      found_component = True

    # A component was found. record the instance info as an Optical_component 
    if found_component:
      # Find text label for DevRec, to get Library name
      library = None
      iter2 = subcell.begin_shapes_rec(LayerDevRecN)
      spice_params = ""
      while not(iter2.at_end()):
        if iter2.shape().is_text():
          text = iter2.shape().text
          print("%s: DevRec label: %s" % (i, text))
          if text.string.find("Lumerical_INTERCONNECT_library=") &gt; -1:
            library = text.string[len("Lumerical_INTERCONNECT_library="):]
          if text.string.find("Lumerical_INTERCONNECT_component=") &gt; -1:
            component = text.string[len("Lumerical_INTERCONNECT_component="):]
          if text.string.find("Spice_param:") &gt; -1:
            spice_params = text.string[len("Spice_param:"):]
        iter2.next()
      if library == None:
        print("Missing library information for component: %s" % component )
      x = iter1.itrans().disp.x*dbu
      y = iter1.itrans().disp.y*dbu
      flip = iter1.trans().is_mirror()
      rotate = (int(iter1.trans().rot())*90) % 360
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, instance, x, y, flip, rotate, library, spice_params) )
      
      # Find the PinRec and record info as Optical_pin
      
      # Use the pin names on layer PinRec to sort the pins in alphabetical order
      # read; sort; save data.
      iter2 = subcell.begin_shapes_rec(LayerPinRecN)
      pin_info1 = []  # array for Pin_info
      path_points=[]
      path_shape=[]
      while not(iter2.at_end()):
        # Find text label for PinRec, to get the port numbers
        if iter2.shape().is_text():
          texto= iter2.shape().text.transformed(iter2.itrans())
          texto= texto.transformed(iter1.itrans())
          x = texto.x
          y = texto.y
          #print( "PinRec label: %s at (%s, %s)" % (iter2.shape().text, x, y) )
          pin_info1.append(Pin_info(iter2.shape().text.string, x, y))
        if iter2.shape().is_path():
          path= iter2.shape().path.transformed(iter2.itrans())
          path= path.transformed(iter1.itrans())
          points = path_to_points(path)  
          #print( "%s: PinRec in cell {%s}, path -- %s"   % (i, iter2.cell().name, path) )
          path_points.append(points)
          path_shape.append(iter2.shape())
        iter2.next()
      # Sort pin text labels
      pin_info2 = sorted(pin_info1, key=lambda  pin_info0: pin_info0.pin_text)

      # find pin labels that are inside the path:
      for p1 in range(0,len(pin_info2)):
        for p2 in range(0,len(path_shape)):
          check_text_in_pin = check_point_in_segment( \
            pya.Point( *path_points[p2][0] ), \
            pya.Point( *path_points[p2][1] ), \
            pya.Point( pin_info2[p1].pin_x, pin_info2[p1].pin_y ) )
          if check_text_in_pin:
            points = path_points[p2]  
            x = (points[0][0]+points[1][0])/2   # midpoint of pin path
            y = (points[0][1]+points[1][1])/2
            pin_idx = len(optical_pins)
            optical_pins.append (Optical_pin (pin_idx, points, component_idx, x, y, 1, pin_info2[p1].pin_text) )
            optical_components[component_idx].npins += 1
            optical_components[component_idx].pins.append( pin_idx )
            print("%s: PinRec (text=%s) in cell {%s}, component #%s, path -- %s"   \
              % (i, pin_info2[p1].pin_text, iter2.cell().name, component_idx, path_to_points(path_shape[p2].path)) )

      # reserve space for netlist for this component, based on the number of pins.
      optical_components[component_idx].nets = [-1] * (optical_components[component_idx].npins)

      # Find the FbrTgt, and record info as Optical_pin
      iter2 = subcell.begin_shapes_rec(LayerFbrTgtN)
      while not(iter2.at_end()):
        if iter2.shape().is_polygon():
          polygon = iter2.shape().polygon.transformed(iter2.itrans())
          polygon = polygon.transformed(iter1.itrans())
          # What do we want to do with the Fibre ports?
          # create a net (with only 1 member = the optical IO)
          net_idx = len(optical_nets)
          optical_nets.append ( Optical_net (net_idx, 2, component_idx, -1, -1) ) #ok
          # create a pin, optical IO
          bb = polygon.bbox()
          x, y = xy_mean_mult([[bb.p1.x, bb.p1.y], [bb.p2.x, bb.p2.y]],1)
#          x, y = numpy.mean([bb.p1.x, bb.p2.x]), numpy.mean([bb.p1.y, bb.p2.y])
          pin_idx = len(optical_pins)
          optical_pins.append (Optical_pin (pin_idx, polygon_to_points(polygon), component_idx, x, y, 2, "pin0") )
          # register the net with the pin and component
          optical_pins[pin_idx].net = net_idx
          optical_components[component_idx].nets.insert(0, net_idx )
          # register the pin with the component
          optical_components[component_idx].npins += 1
          optical_components[component_idx].pins.insert(0, pin_idx ) 
          print("%s: FbrTgt in cell {%s}, at (%s, %s), net %s, pins %s, component # %s, component nets %s" \
              % (i, iter2.cell().name, x, y, net_idx, optical_components[component_idx].pins, \
              component_idx, optical_components[component_idx].nets ) )
        iter2.next()


    # end if found_component   
     
    iter1.next()
 
  # end while iter1 
# end def find_all_components


def distance_xy ( p1, p2 ):
  # calculate the distance between two points
  # input in dbu
  # output in microns
  distance = math.sqrt ( (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 ) * dbu  
  return distance


import math
def angle_segment(seg):
  pt1, pt2 = seg
  x2, y2 = pt2
  x1, y1 = pt1
  rads1 = math.atan2(y2-y1,x2-x1)
  return (rads1)/math.pi*180

def angle_vectors(pt1, pt2):
  x1, y1 = pt1
  x2, y2 = pt2
  rads1 = math.atan2(y1,x1)
  rads2 = math.atan2(y2,x2)
  return (rads2-rads1)/math.pi*180

def angle_segments(segA, segB):
  ptA1, ptA2 = segA
  ptB1, ptB2 = segB
  return angle_vectors([ptA2[0]-ptA1[0], ptA2[1]-ptA1[1]], [ptB2[0]-ptB1[0], ptB2[1]-ptB1[1]])

def av_angle_segments(segA, segB):
  ptA1, ptA2 = segA
  ptB1, ptB2 = segB
  angleA = math.atan2(ptA2[1]-ptA1[1], ptA2[0]-ptA1[0])
  angleB = math.atan2(ptB2[1]-ptB1[1], ptB2[0]-ptB1[0])
  return (angleA+angleB)/2/math.pi*180
#  return angle_vectors([ptA2[0]-ptA1[0], ptA2[1]-ptA1[1]], [ptB2[0]-ptB1[0], ptB2[1]-ptB1[1]])


def points_per_circle(radius):
  # Calculate the recommended number of points in a circle, based on 
  # http://stackoverflow.com/questions/11774038/how-to-render-a-circle-with-as-few-vertices-as-possible
  # radius in microns
#  import numpy as n
  error=0.5e-3 # 0.5 nm
  if radius &gt; 0:
    th = math.acos(2 * (1 - error / radius)**2 - 1)
    num_vertices = math.ceil(2*math.pi/th)
    return num_vertices
  else:
    return 10

def path_to_points(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and construct array
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = advance_iterator(p_iter)
       # assume input Integer type; need to round due to floating point issues.
       points.append( [int(round(p.x)), int(round(p.y))] )
  except StopIteration:
    pass    
  return points


def path_to_Dpoints(path):
  # function to convert a KLayout Path object to an array of points
  # iterate through all the points in the path, and 
  p_iter = path.each_point()
  points = []
  try:
    while True:
       p = advance_iterator(p_iter)
       points.append( [(p.x), (p.y)] )
  except StopIteration:
    pass    
  return points

  
def points_to_Dpath(points, w):
  a1 = []
  for p in points:
    a1.append (pya.DPoint(p[0], p[1]))
  wg_path1 = pya.DPath(a1, w)
  return wg_path1


def points_to_path(points, w):
  a1 = []
  for p in points:
    a1.append (pya.Point(p[0], p[1]))
  wg_path = pya.Path(a1, w)
  return wg_path
  
  
def polygon_to_points(polygon):
  # for some reason, you can assign points to a polygon, but not read them!
  # http://www.klayout.de/doc/code/class_SimplePolygon.html
  # This function reads the points one by one and returns an array of points
  npts = polygon.to_simple_polygon().points
  ps = polygon.to_simple_polygon()
  points = []
  for k in range(0,npts):
    pt = ps.point(k)
    points.append ( [pt.x, pt.y] )
  return points
  

def check_point_in_segment(a, b, c):
    """ How can you determine a point is between two other points on a line segment?
    http://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment
    by Cyrille Ka.  Check if c is between a and b? """
    # print( "%s, %s; %s, %s; %s, %s" % (a.x, a.y, b.x, b.y, c.x, c.y) )
    crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y)
    if abs(crossproduct) != 0 : return False 
    dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y)*(b.y - a.y)
    if dotproduct &lt; 0 : return False
    squaredlengthba = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)
    if dotproduct &gt; squaredlengthba: return False
    return True


def PCell_get_parameter_list ( cell_name, library_name ):
  # function to list all the parameters &amp; defaults for a PCell
  # example usage:
  # PCell_get_parameter_list("CIRCLE", "Basic")
  print("* def PCell_get_parameter_list ( %s, %s): ") % ( cell_name, library_name )
  lib = pya.Library.library_by_name(library_name)
  if lib == None:
    raise Exception("Unknown lib '%s'" % library_name)
  pcell_decl = lib.layout().pcell_declaration(cell_name);
  if pcell_decl == None:
     raise Exception("Unknown PCell '%s'" % cell_name)
  type2s = ['TypeBoolean', 'TypeDouble', 'TypeInt', 'TypeLayer', 'TypeList', 'TypeNone', 'TypeShape', 'TypeString']
  for p in pcell_decl.get_parameters():
    if ~p.readonly:
      print( "Name: %s, %s, unit: %s, default: %s, description: %s%s" % \
        (p.name, type2s[p.type], p.unit, p.default, p.description, ", hidden" if p.hidden else ".") )


def PCell_get_parameters ( pcell ):
  # function to list the values for all parameters for an intantiated PCell
  # example usage:
  # ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
  # pcell = ly.create_cell("CIRCLE", "Basic", { "actual_radius": 10, "layer": pya.LayerInfo(1, 0) } )
  # PCell_get_parameters( pcell )
  print("* def PCell_get_parameters ( %s ):") % pcell 
  print( pcell.pcell_parameters() )
  params = pcell.pcell_parameters_by_name()
  for param in params.keys():
    print("Parameter: %s, Value: %s") % (param, params[param])
  return params
  
def find_PCell_pins(subcell):
  # find the location of the pins in the cell.
  # example usage:
  # ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
  # pcell = ly.create_cell("Waveguide_Bend", "SiEPIC", { } )
  # find_PCell_pins( pcell )

  LayerPinRecN = subcell.layout().layer(LayerPinRec)
  iter2 = subcell.begin_shapes_rec(LayerPinRecN)
  pins = {} # dictionary for pin information
  while not(iter2.at_end()):
    # Find text label for PinRec, to get the port numbers
    if iter2.shape().is_text():
      texto= iter2.shape().text.transformed(iter2.itrans())
      x = texto.x
      y = texto.y
      text = iter2.shape().text
#      print( "PinRec label: %s at (%s, %s)" % (text, x, y) )
      pins[ str(text.string) + "_x" ] = x
      pins[ str(text.string) + "_y" ] = y
    iter2.next()

  return pins
  


def get_LumericalINTERCONNECT_analyzers(topcell, optical_pins):
  """
  Find - LumericalINTERCONNECT_Laser
       - LumericalINTERCONNECT_Detector
  get their parameters
  determine which OpticalIO they are connected to, and find their nets
  Assume that the detectors and laser are on the topcell (not subcells); don't perform transformations.
  
  returns: parameters, nets in order
  
  usage:
  laser_net, detector_nets, wavelength_start, wavelength_stop, wavelength_points = get_LumericalINTERCONNECT_analyzers(topcell, optical_pins)
  """
  
  layout = topcell.layout()
  LayerINTERCONNECTN = layout.layer(LayerINTERCONNECT)

  # data structure used to find the detectors and which optical nets they are connected to.
  class Detector_info:
    def __init__(self, detector_net, detector_number):
      self.detector_net = detector_net
      self.detector_number = detector_number
  detectors_info = []  
      
  # Find the laser and detectors in the layout.
  iter1 = topcell.begin_shapes_rec(LayerINTERCONNECTN)
  n_laser = 0
  laser_net = -1
  wavelength_start, wavelength_stop, wavelength_points = 0,0,0
  n_detector = 0
  while not(iter1.at_end()):
    subcell = iter1.cell()             # cell (component) to which this shape belongs
    if iter1.shape().is_box():
      box = iter1.shape().box.transformed(iter1.itrans())
      if iter1.cell().basic_name() == "LumericalINTERCONNECT_Detector":
        n_detector += 1
        detector_number = subcell.pcell_parameters_by_name()["number"]
        print("%s: Detector {%s} %s, box -- %s; %s"   % (n_detector, subcell.basic_name(), detector_number, box.p1, box.p2) )
        npins_inside_detector = 0
        for pin in optical_pins:
          if pin.pin_type == 2:  # Optical IO
            # Check if the OpticalIO x,y is inside the detector box
            pin_box = pya.Box(pin.x, pin.y, pin.x, pin.y)
            if pin_box.inside(box):
              # found optical
              print("Optical IO pin connected to detector.  Pin #%s: component_idx %s, pin_type %s, net: %s, (%s, %s)" %\
                  (pin.idx, pin.component_idx, pin.pin_type, pin.net, pin.x, pin.y) )
              npins_inside_detector += 1
              detectors_info.append( Detector_info(pin.net, detector_number) ) 
        if npins_inside_detector &gt; 1:
          print(" *** Error - more than 1 optical IO connected to the detector. ")
      if iter1.cell().basic_name() == "LumericalINTERCONNECT_Laser":
        n_laser += 1
        print("%s: Laser {%s}, box -- %s; %s"   % (n_laser, subcell.basic_name(), box.p1, box.p2) )
        wavelength_start = subcell.pcell_parameters_by_name()["wavelength_start"]
        wavelength_stop = subcell.pcell_parameters_by_name()["wavelength_stop"]
        wavelength_points = subcell.pcell_parameters_by_name()["npoints"]
        npins_inside_laser = 0
        for pin in optical_pins:
          if pin.pin_type == 2:  # Optical IO
            # Check if the OpticalIO x,y is inside the laser box
            pin_box = pya.Box(pin.x, pin.y, pin.x, pin.y)
            if pin_box.inside(box):
              # found optical
              print("Optical IO pin connected to laser.  Pin #%s: component_idx %s, pin_type %s, net: %s, (%s, %s)" %\
                  (pin.idx, pin.component_idx, pin.pin_type, pin.net, pin.x, pin.y) )
              npins_inside_laser += 1
              laser_net = pin.net  
        if npins_inside_laser &gt; 1:
          print(" *** Error - more than 1 optical IO connected to the laser. ")
            
    iter1.next()
    
  # Sort the detectors:
  detectors_info2 = sorted(detectors_info, key=lambda  d: d.detector_number)
    
  # output:
  detector_nets = []
  for d in detectors_info2:
    detector_nets.append (d.detector_net)

  return laser_net, detector_nets, wavelength_start, wavelength_stop, wavelength_points
    
  
def find_all_waveguides(cell, layer):
  # function to traverse the entire layout hierarchy and find all the waveguides 
  # returns array listing all paths
  # Search for ROUND_PATH PCells and straight paths

  # return data containing:
  # - net id: unique identifier for the net
  # - vertices: points that make up the path

  dbu = cell.layout().dbu
  
  iter1 = cell.begin_shapes_rec(layer)
  i=0
  while not(iter1.at_end()):
    i+=1
    found_wg = False
    
    if iter1.shape().is_path():
      # This is a waveguide that is a path.  It should be only a straight line with no bends
      path_obj= iter1.shape()
      wg_path = path_obj.path
      num_points = path_obj.path.num_points()
      if num_points == 2:
        # insert a mid-point in the waveguide, so that it can later be split into two nets
        points = path_to_points(path_obj)
        a1 = []
        count =0
        for p in points:
          a1.append (pya.Point(p[0], p[1]))
          count += 1
          if count == 1:
            # add a point:
            a1.append( pya.Point( (points[0][0] + points[1][0])/2, (points[0][1] + points[1][1])/2 )  )
        wg_path = pya.Path(a1, path_obj.path.width)
      path = wg_path.transformed(iter1.itrans())   # get the path description        
      # Waveguide parameters
      length =  path.length()*dbu 
      radius = 0
      wg_type = 0
      bend_pts = 0
      wg_width = path.width*dbu
      print("Waveguide #%s: In cell {%s}, num_points: %s, length: %s, radius: %s, path: %s"  \
           % (i, iter1.cell().name, num_points, length, radius, path) )
      found_wg = True
      
    if iter1.shape().is_polygon():
      if iter1.cell().basic_name() == "ROUND_PATH" or \
        (iter1.cell().basic_name() == "Waveguide_Route" and WAVEGUIDE_extract_simple ):
        # This is a waveguide implemented using a PCell ROUND_PATH
        subcell = iter1.cell()
        if subcell.is_pcell_variant():    
          # Get the waveguide guiding shape path from the "ROUND_PATH" PCell 
          DPath = subcell.pcell_parameters_by_name()["path"]*(1/dbu)  # DPath object
          ipath = pya.Path.from_dpath(DPath)  # Construct an integer-coordinate path from a floating-point coordinate one

          # Find out the transformation that needs to be performed on the path relative to the top cell
          # and apply this on the waveguide guiding shape path
          trans = iter1.trans() # CplxTrans object of the instance 
          DCplxTrans = pya.DCplxTrans.from_itrans(trans) # need CplxTrans to DCplxTrans
          path = DPath.transformed(DCplxTrans)

          # Waveguide parameters
          print(subcell.pcell_parameters_by_name())
          radius = subcell.pcell_parameters_by_name()["radius"]  # in microns
          bend_pts = subcell.pcell_parameters_by_name()["npoints"] 
          wg_width = subcell.pcell_parameters_by_name()['path'].width  # in microns
          # calculate the length of the waveguide using the area / width
          iter2 = subcell.begin_shapes_rec(LayerSiN)
          if iter2.shape().is_polygon():
            area = iter2.shape().polygon.area()
            length = area / wg_width * dbu * dbu
          else:
            print("## ROUND_PATH waveguide, not polygon; bug in code? ##")
            length =  path.length()*dbu  # ignoring bends
          num_points = path.num_points()
          wg_type = 1
          print("Waveguide #%s: In cell {%s}, num_points: %s, length: %s, radius: %s, path: %s" \
              % (i, subcell.name, num_points, length, radius, path) )
          found_wg = True
        else:
          print("## ROUND_PATH cell, but not a PCell. Can't extract info. ##")
          v = pya.MessageBox.warning("Can't extract waveguide", "Verification warning: Can't extract waveguide.\nFound a %s waveguide, but it isn't a PCell. \nNote: This verification only works on original KLayout-created layouts (not merged)." % iter1.cell().basic_name(), pya.MessageBox.Ok)

    if found_wg:
      points = path_to_points(path)  
      print("path: %s, points: %s" % (path, points) )
      # save waveguide info into the Optical_waveguide
      optical_waveguides.append ( Optical_waveguide (len(optical_waveguides), points, radius, \
          length, wg_type, num_points, wg_width, bend_pts ) )

    iter1.next()
  print(" ")


 

def check_segments_colinear_overlapping( segment1, segment2 ):
  """ 
  we want to identify ONLY the following situation:
        X  O  X  O
  where XX is a segment, and OO is another segment
  namely, colinear, but also XX overlapping OO
  example usage: 
    a = pya.Point(0,0)
    b = pya.Point(50,0)
    c = pya.Point(50,0)
    d = pya.Point(100,0)
    segment1 = [ a, b ]
    segment2 = [ c, d ]
    print(check_segments_colinear_overlapping( segment1, segment2 ))
  """  
  # check for one of the segment2 points being inside segment1
  check_between1 = check_point_in_segment( segment1[0], segment1[1], segment2[0] ) | \
                  check_point_in_segment( segment1[0], segment1[1], segment2[1] )
  # check for one of the segment1 points being inside segment2
  check_between2 = check_point_in_segment( segment2[0], segment2[1], segment1[0] ) | \
                  check_point_in_segment( segment2[0], segment2[1], segment1[1] )
  # check that they have the same direction
  is_slope_equal = False
  # check ∆x = 0 first to avoid division by 0
  dx1 = (segment1[0].x-segment1[1].x)
  dx2 = (segment2[0].x-segment2[1].x)
  if dx2 == 0 and dx1 == 0:
    is_slope_equal = True  # both vertical
  elif dx1 != 0 and dx2 != 0:
    # check slopes
    slope1 = (segment1[0].y-segment1[1].y) / (segment1[0].x-segment1[1].x)
    slope2 = (segment2[0].y-segment2[1].y) / (segment2[0].x-segment2[1].x)
    if slope1 == slope2:
      is_slope_equal = True  # both have the same slope

  return check_between1 and check_between2 and is_slope_equal


def identify_all_nets(optical_pins, optical_waveguides, optical_components):
  # function to identify all the nets from the layout
  # use the data in Optical_pin, Optical_waveguide to find overlaps
  # and save results in Optical_component

  # Make sure that there are exactly 2 pins for each net (not like in electronics!)

  # Loop through all the pins (p1)
  # - find other overlapping pins (p2)
  # - find overlapping waveguide ends
  for p1 in optical_pins:
    if p1.pin_type != 1:
      continue # only analyze pin_type = 1, component.
      
    segment1 = [ pya.Point(*p1.points[0]), pya.Point(*p1.points[1]) ] 

    # Compare to all other pins:
    for p2 in optical_pins[ p1.idx+1: len(optical_pins) ]:
      if p2.pin_type != 1:
        continue # only analyze pin_type = 1, component.
      #print("%s, %s, %s, %s" % (p1.n, p1.points, p2.n, p2.points) )
      segment2 = [ pya.Point(*p2.points[0]), pya.Point(*p2.points[1]) ] 
      # first check that the pins are pointing in the same direction and overlapping:
      check = check_segments_colinear_overlapping( segment1, segment2 )
      # then check that the pin centres are perfectly overlapping (to avoid phase errors in simulations, slight disconnections)
      x1 = (p1.points[0][0]+p1.points[1][0])/2   # midpoint of pin path
      y1 = (p1.points[0][1]+p1.points[1][1])/2
      x2 = (p2.points[0][0]+p2.points[1][0])/2   # midpoint of pin path
      y2 = (p2.points[0][1]+p2.points[1][1])/2
      check2 = (x1 == x2) and (y1 == y2)
      if check and check2:  # found connected pins:
        # make a new optical net
        net_idx = len(optical_nets)
        # optical net connects two pins; keep track of pin index:
        optical_nets.append ( Optical_net (net_idx, 1, p1.idx, 1, p2.idx) )
        # assign this net number to the components
        # find which where p1 and p2 are in the component:
        p1_comp = optical_components[p1.component_idx]
        p2_comp = optical_components[p2.component_idx]
        p1_comp.nets[p1_comp.pins.index(p1.idx)] = net_idx
        p2_comp.nets[p2_comp.pins.index(p2.idx)] = net_idx
        # assign this net number to the pins
        p1.net = net_idx
        p2.net = net_idx
        print( "connected: pin-pin, net: %s, component,pin #: [%s, %s], [%s, %s]" % (net_idx, p1.component_idx, p1.pin_name, p2.component_idx, p2.pin_name) )
        
    # Compare to all waveguides:
    for w1 in optical_waveguides:
      # examine the beginning of the waveguide:
      segment2 = [ pya.Point(*w1.points[0]), pya.Point(*w1.points[1]) ] 
      # first check that the pin is pointing in the same direction and overlapping as the waveguide segment:
      check1 = check_segments_colinear_overlapping( segment1, segment2 )
      # then check that the waveguide endpoint is perfectly at the pin centre
      x1 = (p1.points[0][0]+p1.points[1][0])/2   # midpoint of pin path
      y1 = (p1.points[0][1]+p1.points[1][1])/2
      x2 = w1.points[0][0]   # endpoint of waveguide
      y2 = w1.points[0][1]
      check1b = (x1 == x2) and (y1 == y2)
      if check1 and check1b:  # found connected pins:
        # make a new optical net
        net_idx = len(optical_nets)
        optical_nets.append ( Optical_net (net_idx, 1, p1.component_idx, 0, w1.idx) )
        # assign this net number to the components
        p1_comp = optical_components[p1.component_idx]
        p1_comp.nets[p1_comp.pins.index(p1.idx)] = net_idx
###        optical_components[p1.component_idx].nets.append (net_idx)
        if optical_waveguides[w1.idx].net1 != -1:
          # problem. Net is already assigned.
          text = "  *** Connectivity error.  Net is already assigned (pin to waveguide). Overwriting."
          flag_waveguide_error( [w1.points[0], w1.points[1]], text, optical_waveguides[w1.idx], topcell)
        optical_waveguides[w1.idx].net1 = net_idx
        # assign this net number to the pin
        p1.net = net_idx
        print( "connected: pin-waveguide, net #: %s, component #: %s, pin #: %s, waveguide #: %s" \
              % (net_idx, p1.component_idx, p1.idx, w1.idx ) )
        
      # examine the end of the waveguide:
      np = len(w1.points)
      segment2 = [ pya.Point(*w1.points[np-2]), pya.Point(*w1.points[np-1]) ] 
      # first check that the pin is pointing in the same direction and overlapping as the waveguide segment:
      check2 = check_segments_colinear_overlapping( segment1, segment2 )
      # then check that the waveguide endpoint is perfectly at the pin centre
      x1 = (p1.points[0][0]+p1.points[1][0])/2   # midpoint of pin path
      y1 = (p1.points[0][1]+p1.points[1][1])/2
      x2 = w1.points[np-1][0]   # endpoint of waveguide
      y2 = w1.points[np-1][1]
      check2b = (x1 == x2) and (y1 == y2)
      if check2 and check2b:  # found connected pins:
        # make a new optical net
        net_idx = len(optical_nets)
        optical_nets.append ( Optical_net (net_idx, 1, p1.component_idx, 0, w1.idx) )
        # assign this net number to the components
        p1_comp = optical_components[p1.component_idx]
        p1_comp.nets[p1_comp.pins.index(p1.idx)] = net_idx
###        optical_components[p1.component_idx].nets.append (net_idx)
        if optical_waveguides[w1.idx].net2 != -1:
          # problem. Net is already assigned.
          text = "  *** Connectivity error.  Net is already assigned (pin to waveguide). Overwriting."
          flag_waveguide_error([w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]], \
                  text, optical_waveguides[w1.idx], topcell)
        optical_waveguides[w1.idx].net2 = net_idx
        # assign this net number to the pin
        p1.net = net_idx
        print( "connected: pin-waveguide, net #: %s, component #: %s, pin #: %s, waveguide #: %s" \
              % (net_idx, p1.component_idx, p1.idx, w1.idx ) )
     

  # Check for waveguide to waveguide connections, make net
  # Loop through all waveguides, and compare to all other waveguides
  for w1 in optical_waveguides:
    # the beginning of waveguide 1:
    w1_segment1 = [ pya.Point(*w1.points[0]), pya.Point(*w1.points[1]) ] 
    # the end of waveguide 2:
    np = len(w1.points)
    w1_segment2 = [ pya.Point(*w1.points[np-2]), pya.Point(*w1.points[np-1]) ] 
    for w2 in optical_waveguides[ w1.idx+1: len(optical_waveguides) ]:
      # the beginning of waveguide 2:
      w2_segment1 = [ pya.Point(*w2.points[0]), pya.Point(*w2.points[1]) ] 
      # the end of waveguide 2:
      np = len(w2.points)
      w2_segment2 = [ pya.Point(*w2.points[np-2]), pya.Point(*w2.points[np-1]) ] 

      # check 4 possibilities:
      for j in range(0,2):
        if j==0:
          w1_seg=w1_segment1
        else:
          w1_seg=w1_segment2
        for k in range(0,2):
          if k==0:
            w2_seg=w2_segment1
          else:
            w2_seg=w2_segment2
            
          # perform comparison between each of the waveguide ends:
          check = check_segments_colinear_overlapping( w1_seg, w2_seg )
          if check:  # found connected pins:
            # make a new optical net
            net_idx = len(optical_nets)
            optical_nets.append ( Optical_net (net_idx, 0, w1.idx, 0, w2.idx) )
            if j==0:
              optical_waveguides[w1.idx].net1 = net_idx
            else:
              optical_waveguides[w1.idx].net2 = net_idx
            if k==0:
              optical_waveguides[w2.idx].net1 = net_idx
            else:
              optical_waveguides[w2.idx].net2 = net_idx
            print("connected: waveguide-waveguide")


# end def identify_all_nets



def identify_all_nets_fast(optical_pins, optical_waveguides, optical_components):
  # function to identify all the nets from the layout
  # use the data in Optical_pin, Optical_waveguide to find overlaps
  # and save results in Optical_component

  # Make sure that there are exactly 2 pins for each net (not like in electronics!)

  # make a database of pins and waveguide ends
  # sort the pins by x, y.  
  # - find overlapping pins / waveguide ends
  
  # data structure used for all pins.
  class All_pins:
    def __init__(self, x, y, pin_type, ):
      self.detector_net = detector_net
      self.detector_number = detector_number
  all_pins = []  


def find_optical_IO_pins(optical_pins):
  pins_text = ""
  for p in optical_pins:
    if p.pin_type == 2:
      pins_text += " N$%s" % p.net
  return pins_text


def generate_Spice_file(topcell, optical_waveguides, optical_components):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X_grating_coupler_1 N$7 N$6 grating_coupler library="custom/genericcml" sch_x=-1.42 sch_y=-0.265 sch_r=0 sch_f=false

  Lumerical_schematic_scaling = 5e-2
#  Lumerical_schematic_scaling = 20e-2

  # convert KLayout GDS rotation/flip to Lumerical INTERCONNECT
  # KLayout defines mirror as an x-axis flip, whereas INTERCONNECT does y-axis flip
  # KLayout defines rotation as counter-clockwise, whereas INTERCONNECT does clockwise
  # input is KLayout Rotation,Flip; output is INTERCONNECT:
  KLayoutInterconnectRotFlip = \
      {(0, False):[0, False], \
       (90, False):[270, False], \
       (180, False):[180, False], \
       (270, False):[90, False], \
       (0, True):[180,True], \
       (90, True):[90, True], \
       (180, True):[0,True], \
       (270, True):[270, False]}

  from time import strftime 
  
  text = '* Spice output from KLayout SiEPIC_EBeam_PDK v%s, %s.\n\n' % (SiEPIC_Version, strftime("%Y-%m-%d %H:%M:%S") )

#wtext.insertHtml('.subckt %s %s:&lt;br&gt;' % ( topcell.name, find_optical_IO_pins(optical_pins) ))
  opticalIO_pins = find_optical_IO_pins(optical_pins)  
  text += '.subckt %s%s\n' % (topcell.name, opticalIO_pins)
  
  for o in optical_components:
  
    nets_str = ""
    for n in o.nets:
      nets_str += " N$" + str(n)

    trans = KLayoutInterconnectRotFlip[(o.rotate, o.flip)]
     
    flip = ' sch_f=true' if trans[1] else ''
    if trans[0] &gt; 0:
      rotate = ' sch_r=%s' % str(trans[0])
    else:
      rotate = ''
#    t = '%s %s %s library="%s" lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s'  % \
#         ( "X"+o.component+"_"+str(o.idx), nets_str, o.component, o.library, str (o.x * 1e-6), o.y * 1e-6, o.x, o.y, rotate, flip)
#    t = '  %s %s %s library="%s" %s $X=%s $Y=%s sch_x=%s sch_y=%s %s%s'  % \
    t = '  %s %s %s library="%s" %s lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s'  % \
         ( "x"+str(o.idx), nets_str, o.component, o.library, o.params, \
         eng_str(o.x * 1e-6), eng_str(o.y * 1e-6), \
         eng_str(o.x * Lumerical_schematic_scaling), eng_str(o.y * Lumerical_schematic_scaling), \
         rotate, flip)
    text += '%s\n' %t

  # list all Optical_waveguides objects from an array
  # input array, optical_waveguides
  # example output:         
  # X5 9 10 ebeam_wg_strip_1550 library="Design kits/ebeam_v1.0" wg_length=7.86299e-06 wg_width=5.085e-07 sch_x=-1.42 sch_y=-0.265

  for o in optical_waveguides:
    nets_str = "N$%s N$%s" %(o.net1, o.net2)
    x,y = xy_mean_mult(o.points, dbu)
#    t = '%s %s %s library="%s" wg_length=%s wg_width=%s lay_x=%s lay_y=%s sch_x=%5.3f sch_y=%5.3f'  % \
#           ( "Xwg" + str(o.idx), nets_str, o.component, o.library, eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
#             eng_str(x * 1e-6), eng_str(y * 1e-6), x, y)
    t = '  %s %s %s library="%s" wg_length=%s wg_width=%s sch_x=%s sch_y=%s points="%s"'  % \
           ( "wg" + str(o.idx), nets_str, o.component, o.library, \
             eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
             eng_str(x * Lumerical_schematic_scaling), eng_str(y * Lumerical_schematic_scaling), \
             str(o.points).replace('[','(').replace(']',')')  )
    text += '%s\n' %t

  text += '.ends %s\n\n' % (topcell.name)

  # Get information about the laser and detectors:
  laser_net, detector_nets, wavelength_start, wavelength_stop, wavelength_points = \
        get_LumericalINTERCONNECT_analyzers(topcell, optical_pins)
  if laser_net &gt; -1:
    text += '* Optical Network Analyzer:\n'
    text += '.ona input_unit=wavelength input_parameter=start_and_stop\n  + minimum_loss=50\n  + analysis_type=scattering_data\n  + multithreading=user_defined number_of_threads=1\n' 
    text += '  + start=%4.3fe-9\n' % wavelength_start
    text += '  + stop=%4.3fe-9\n' % wavelength_stop
    text += '  + number_of_points=%s\n' % wavelength_points
    for i in range(0,len(detector_nets)):
      text += '  + input(%s)=%s,N$%s\n' % (i+1, topcell.name, detector_nets[i])
    text += '  + output=%s,N$%s\n' % (topcell.name, laser_net)

  # main circuit
  text += '%s%s %s sch_x=-1 sch_y=-1\n\n' % (topcell.name, opticalIO_pins, topcell.name)

  return text, len(detector_nets)


def eng_str(x):
    import math
    # x input in meters
    # output in meters, engineering notation, rounded to 1 nm
    
    EngExp_notation = 1 # 1 = "1.0e-6", 0 = "1.0u"
    x = round(x*1E9)/1E9
    y = abs(x)
    if y == 0:
      return '0'
    else:
      exponent = int(math.floor(math.log10(y)))
      engr_exponent = exponent - exponent%3
      if engr_exponent == -3:
        str_engr_exponent = "m"
        z = y/10**engr_exponent
      elif engr_exponent == -6:
        str_engr_exponent = "u"
        z = y/10**engr_exponent
      elif engr_exponent == -9:
        str_engr_exponent = "n"
        z = y/10**engr_exponent
      else:
        str_engr_exponent = ""
        z = y/10**engr_exponent
      sign = '-' if x &lt; 0 else ''
      if EngExp_notation:
        return sign+str(z)+'E'+str(engr_exponent)
#      return sign+ '%3.3f' % z +str(str_engr_exponent)
      else:
        return sign+ str(z) +str(str_engr_exponent)


def netlist_extraction(topcell):
  # Collection of functions to extract the circuit netlist from the physical layout
  
  import time

  # Search the layout for the components and waveguides:
  print("")
  print("* calling find_all_components() – DevRec:")
  find_all_components(topcell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN)
  clock_find_all_components = time.clock()

  print("")
  print("* calling find_all_waveguides():")
  find_all_waveguides(topcell, LayerSiN)
  clock_find_all_waveguides = time.clock()

  print("")
  print("* print_Optical_all, after find_all_{components, waveguides}:")
  print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)

  # Search the arrays to identify all the nets:
  print("")
  print("* calling identify_all_nets():")
  identify_all_nets(optical_pins, optical_waveguides, optical_components)
  clock_identify_all_nets = time.clock()

  print("")
  print("print_Optical_all, after identify_all_nets:")
  print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)

  return optical_waveguides, optical_components, \
  clock_find_all_components, clock_find_all_waveguides, clock_identify_all_nets


  
def flag_waveguide_error(dpoints, text, optical_waveguide, topcell):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  a1 = []
  for p in dpoints:
    a1.append (pya.Point(int(p[0]), int(p[1])))
  path = pya.Path(a1, optical_waveguide.wg_width*4/dbu)
  x,y = xy_mean_mult(dpoints, dbu)
  layout_errors.append(Layout_error(text, x, y) )
  print(text)
  if 'wtext' in globals():
    topcell.shapes(LayerErrorN).insert(path)
    wtext.insertHtml('%s&lt;br&gt;' %text)


def check_waveguides(rdb, optical_waveguides, topcell, error_layer):
  # check waveguides for basic errors.
  num_errors=0

  rdb_cell = next(rdb.each_cell())

  rdb_cat_id_wg = rdb.create_category("Waveguide errors")
  
  rdb_cat_id_wg_path = rdb.create_category(rdb_cat_id_wg, "Path")
  rdb_cat_id_wg_path.description = "Waveguide path: Only 2 points allowed in a path. Convert to a waveguide (ROUND_PATH) if necessary."

  rdb_cat_id_wg_radius = rdb.create_category(rdb_cat_id_wg, "Radius")
  rdb_cat_id_wg_radius.description = "Not enough space to accommodate the desired bend radius for the waveguide end."

  rdb_cat_id_wg_bendpts = rdb.create_category(rdb_cat_id_wg, "Bend points")
  rdb_cat_id_wg_bendpts.description = "Waveguide bend should have more points per circle."

  rdb_cat_id_wg_manhattan = rdb.create_category(rdb_cat_id_wg, "Manhattan")
  rdb_cat_id_wg_manhattan.description =  "The first and last waveguide segment need to be Manhattan (vertical or horizontal) so that they can connect to device pins."


  for o in optical_waveguides:

    # Check for paths with &gt; 2 vertices
    if (o.wg_type == 0 and o.num_points &gt; 2):
      text = "  *** Layout error.  Waveguide path (%s, %s): Only 2 points allowed in a path. Convert to a waveguide (ROUND_PATH) if necessary. " \
            % ( o.points[0][0]*dbu, o.points[0][1]*dbu) 
      dpoints = o.points
      num_errors += 1
      flag_waveguide_error(dpoints, text, o, topcell)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_path.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )

    # find the minimum segment to make sure that the bends have large enough radius
    if (o.wg_type == 1):
      # first segment:
      segment = distance_xy ( o.points[0], o.points[1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for waveguide end." % (segment, o.radius)
        dpoints=[ o.points[0], o.points[1] ] 
        num_errors += 1
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_radius.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # last segment:
      segment = distance_xy ( o.points[len(o.points)-2], o.points[len(o.points)-1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for waveguide end." % (segment, o.radius)
        dpoints=[ o.points[len(o.points)-2], o.points[len(o.points)-1] ]
        num_errors += 1
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_radius.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # go through each of the middle segments:
      for j in range(1, len(o.points)-2):
        segment = distance_xy ( o.points[j], o.points[j+1] ) 
        if segment &lt; 2*o.radius and segment != 0:
          text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for a mid-segment." % (segment, o.radius)
          dpoints=[ o.points[j], o.points[j+1] ] 
          num_errors += 1
          flag_waveguide_error(dpoints, text, o, topcell)
          rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_radius.rdb_id())
          rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )

      # Check for waveguides with too few bend points
      recommended_points = points_per_circle(o.radius)
      if o.bend_pts &lt; 0.75 * recommended_points:
        text =  "  *** Layout warning.  Waveguide bends should have at least %s points per circle for a %s micron radius." \
                     % (int(recommended_points), o.radius)
        dpoints=o.points
        num_errors += 1
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_bendpts.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # Check if waveguide end segments are Manhattan; this ensures they can connect to a pin
      # first segment
      if ( o.points[0][0] != o.points[1][0] and o.points[0][1] != o.points[1][1] ):
        num_errors += 1
        text =  "  *** Layout warning.  The first and last waveguide segment need to be Manhattan (vertical or horizontal) so that they can connect to device pins."
        dpoints=[ o.points[0], o.points[1] ] 
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_manhattan.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )
      # last segment
      last = len(o.points)-1
      if ( o.points[last][0] != o.points[last-1][0] and o.points[last][1] != o.points[last-1][1] ):
        num_errors += 1
        text =  "  *** Layout warning.  The first and last waveguide segment need to be Manhattan (vertical or horizontal) so that they can connect to device pins."
        dpoints=[ o.points[last-1], o.points[last] ]
        flag_waveguide_error(dpoints, text, o, topcell)
        rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_wg_manhattan.rdb_id())
        rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),o.wg_width) ) )

  return num_errors


def check_components(rdb, cell, LayerDevRecN):
  # function to go through all the cells
  # check that the cell has at most ONE DevRec shape.  
  return False
 
 

def flag_component_error(box, text, x, y):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  layout_errors.append(Layout_error(text, x, y) )
  print(text)
  if 'wtext' in globals():
    topcell.shapes(LayerErrorN).insert(box)
    wtext.insertHtml('%s&lt;br&gt;' %text)


def check_connectivity(rdb, optical_components, topcell, LayerErrorN):
  # Make sure that all pins/waveguides are connected, i.e., dangling pins/waveguides.
  # Flag disconnected pins
  # Flag disconnected waveguides
  # Make sure that waveguides / pins are connected in the correct direction (identify_nets only finds colinear pins/waveguides) 

  num_errors=0

  rdb_cell = next(rdb.each_cell())

  rdb_cat_id = rdb.create_category("Connectivity errors")

  rdb_cat_id_discwg = rdb.create_category(rdb_cat_id, "Disconnected waveguide")
  rdb_cat_id_discwg.description = "Disconnected waveguides"

  rdb_cat_id_discpin = rdb.create_category(rdb_cat_id, "Disconnected pin")
  rdb_cat_id_discpin.description = "Disconnected pin"

  if 0:
   for k in range(0,len(optical_components)):
    if optical_components[k].npins != len(optical_components[k].nets):
      text = "  *** Connectivity error.  Mismatch between the number of pins (%s) on the component (%s, %s) at (%s, %s), and the number of nets (%s)." \
            % ( optical_components[k].npins, optical_components[k].component, optical_components[k].idx, \
                optical_components[k].x, optical_components[k].y, len(optical_components[k].nets) )
      bbox = layout.cell(optical_components[k].instance).bbox()
      box = bbox.transformed(pya.Trans(optical_components[k].rotate, optical_components[k].flip, \
                optical_components[k].x/dbu,optical_components[k].y/dbu))
#      flag_component_error(box, text, optical_components[k].x, optical_components[k].y)

      # go through all the pins in the component, and check if they aren't assigned to a net
      for m in range(0,optical_components[k].npins):
        pin = optical_pins[optical_components[k].pins[m]]
        if pin.net == 0 and pin.pin_type == 1:  # disconnected pin on a pin_type = 1 (component)
          text = "  *** Found disconnected pin #%s at (%s, %s)." % (pin.idx, pin.x*dbu, pin.y*dbu)
          box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
#          flag_component_error(box, text, pin.x*dbu, pin.y*dbu)

  for pin in optical_pins:
    if pin.net == -1 and pin.pin_type != 2:  # disconnected pin not on a pin_type = 2 (optical IO)
      text = "  *** Found disconnected pin #%s, type %s, at (%s, %s), component #%s {%s}" \
          % (pin.idx, pin.pin_type, pin.x*dbu, pin.y*dbu, \
             pin.component_idx, optical_components[pin.component_idx].component)
      box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
      num_errors += 1
      flag_component_error(box, text, pin.x*dbu, pin.y*dbu)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_discpin.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( pya.DBox(pin.x*dbu-0.3, pin.y*dbu-0.3, pin.x*dbu+0.3, pin.y*dbu+0.3) ) )

  for w1 in optical_waveguides:
    print(w1.points)
    # examine the beginning of the waveguide:
    if w1.net1 == -1:
      text = "  *** Found disconnected waveguide at (%s, %s), net1" \
          % (w1.points[0][0]*dbu, w1.points[0][1]*dbu)
      dpoints = [w1.points[0], w1.points[1]]
      num_errors += 1
      flag_waveguide_error( dpoints, text, optical_waveguides[w1.idx], topcell)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_discwg.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),w1.wg_width) ) )
    # examine the end of the waveguide:
    if w1.net2 == -1:
      text = "  *** Found disconnected waveguide at (%s, %s), net2" \
          % (w1.points[len(w1.points)-1][0]*dbu, w1.points[len(w1.points)-1][1]*dbu)
      dpoints = [w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]]
      print(dpoints)
      num_errors += 1
      flag_waveguide_error(dpoints, \
               text, optical_waveguides[w1.idx], topcell)
      rdb_item = rdb.create_item(rdb_cell.rdb_id(),rdb_cat_id_discwg.rdb_id())
      rdb_item.add_value(pya.RdbItemValue( points_to_Dpath(points_mult(dpoints, dbu),w1.wg_width) ) )

  return num_errors
    


def list_optical_components(optical_components):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X_grating_coupler_1 N$7 N$6 grating_coupler library="custom/genericcml" sch_x=-1.42 sch_y=-0.265 sch_r=0 sch_f=false

  for o in optical_components:
    nets_str = ""
    for n in o.nets:
      nets_str += " N$" + str(n)
    flip = ' sch_f=true' if o.flip else ''
    if o.rotate &gt; 0:
      rotate = ' sch_r=%s' % str(o.rotate)
    else:
      rotate = ''
#    t = '%s %s %s library="%s" lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s'  % \
#         ( "X"+o.component+"_"+str(o.idx), nets_str, o.component, o.library, str (o.x * 1e-6), o.y * 1e-6, o.x, o.y, rotate, flip)
    t = '  %s %s %s library="%s" sch_x=%s sch_y=%s %s%s'  % \
         ( "X"+o.component+"_"+str(o.idx), nets_str, o.component, o.library, eng_str(o.x * 5e-2), eng_str(o.y * 5e-2), rotate, flip)
    print(t)
    wtext.insertHtml('%s&lt;br&gt;' %t)

def list_optical_waveguides(list_optical_waveguides):
  # list all Optical_waveguides objects from an array
  # input array, optical_waveguides
  # example output:         
  # X5 9 10 ebeam_wg_strip_1550 library="Design kits/ebeam_v1.0" wg_length=7.86299e-06 wg_width=5.085e-07 sch_x=-1.42 sch_y=-0.265

  for o in list_optical_waveguides:
    nets_str = "N$%s N$%s" %(o.net1, o.net2)
    x,y = xy_mean_mult(o.points, dbu)
#    t = '%s %s %s library="%s" wg_length=%s wg_width=%s lay_x=%s lay_y=%s sch_x=%5.3f sch_y=%5.3f'  % \
#           ( "Xwg" + str(o.idx), nets_str, o.component, o.library, eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
#             eng_str(x * 1e-6), eng_str(y * 1e-6), x, y)
    t = '  %s %s %s library="%s" wg_length=%s wg_width=%s sch_x=%s sch_y=%s'  % \
           ( "Xwg" + str(o.idx), nets_str, o.component, o.library, \
             eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), eng_str(x * 5e-2), eng_str(y * 5e-2))
    print(t)
    wtext.insertHtml('%s&lt;br&gt;' %t)




def terminate_all_disconnected_pins(optical_pins, optical_waveguides, optical_components):
  """
  Find all disconnected pins, and add a disconnected component for circuit simulations
  to properly account for reflections.
  Function based on check_connectivity().
  
  steps:
   - Find all disconnected pins &amp; waveguides
   - to do: attempt to recognize if it is connected to a TE or TM circuit
   - Add "disconnected" component to all disconnected pins &amp; waveguides
  """

  print ("running - terminate_all_disconnected_pins():")

  # attach a TE disconnected component to disconnected pins.
  component = "ebeam_disconnected_te1550"  # disconnected pin model name
  library = "Design kits/ebeam_v1.2" # compact model library
  
  for pin in optical_pins:
    if pin.net == -1 and pin.pin_type != 2:  # disconnected pin not on a pin_type = 2 (optical IO)
      x, y = pin.x*dbu, pin.y*dbu
      text = "  *** Found disconnected pin #%s, type %s, at (%s, %s), component #%s {%s}" \
          % (pin.idx, pin.pin_type, x, y, \
             pin.component_idx, optical_components[pin.component_idx].component)
      print(text)

      # Add "disconnected" component:
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, component, x, y, 0, 0, library, "") )
      # Make an optical net
      net_idx = len(optical_nets)
      optical_nets.append ( Optical_net (net_idx, 1, pin.component_idx, \
                            1, optical_components[component_idx].idx) )
      # update pin
      pin.net = net_idx
      # update the two components.  find where the pin is in the first component.
      optical_components[pin.component_idx].nets\
          [optical_components[pin.component_idx].pins.index(pin.idx)] \
          = net_idx
      optical_components[component_idx].nets.append ( net_idx )
        
  for w1 in optical_waveguides:
    # examine the beginning of the waveguide:
    if w1.net1 == -1:
      x, y = w1.points[0][0]*dbu, w1.points[0][1]*dbu
      text = "  *** Found disconnected waveguide at (%s, %s), net1" \
          % (x, y)
      print(text)
      
      # Add "disconnected" component:
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, component, x, y, 0, 0, library, "") )
      # Make an optical net
      net_idx = len(optical_nets)
      optical_nets.append ( Optical_net (net_idx, 0, w1.idx, \
                            1, optical_components[component_idx].idx) )
      # update pin
      pin.net = net_idx
      # update the new component.  
      optical_components[component_idx].nets.append ( net_idx )
      # update the waveguide
      w1.net1 = net_idx

    # examine the end of the waveguide:
    if w1.net2 == -1:
      x, y = w1.points[len(w1.points)-1][0]*dbu, w1.points[len(w1.points)-1][1]*dbu
      text = "  *** Found disconnected waveguide at (%s, %s), net2" \
          % (x,y)
      print(text)

      # Add "disconnected" component:
      component_idx = len(optical_components)
      optical_components.append ( Optical_component (component_idx, \
                  component, component, x, y, 0, 0, library, "") )
      # Make an optical net
      net_idx = len(optical_nets)
      optical_nets.append ( Optical_net (net_idx, 0, w1.idx, \
                            1, optical_components[component_idx].idx) )
      # update pin
      pin.net = net_idx
      # update the new component.  
      optical_components[component_idx].nets.append ( net_idx )
      # update the waveguide
      w1.net2 = net_idx

  return optical_waveguides, optical_components



def waveguide_set_target_length():
  # Function to move the edges of a waveguide to obtain a target length
  # - Dialog prompts user for a target length, and to click on an edge to select shape and edge to move
  # - Newton search: calculate length (area method) then move edge; technique is general for any waveguide curve function
  pass
    </text>
</klayout-macro>
