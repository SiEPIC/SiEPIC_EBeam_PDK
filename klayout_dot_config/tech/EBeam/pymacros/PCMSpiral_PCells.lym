<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>'''
MIT License

Copyright (c) 2017 Stephen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'''

import pya
import math
import cmath
from pya import *
from SiEPIC.utils import get_technology, get_technology_by_name

MODULE_NUMPY = True

dbu = 0.001
pi = cmath.pi
j = cmath.sqrt(-1)
sign = lambda x: math.copysign(1,x) #define the sign function
alpha = 1 #related to the spirals radius growth, can only guess and test so far

r = 16.0 #radius of the Sbend spiral
gap = 4.0 #gap between wgs
angle_stepsize = 0.0001 #0.00001 required for less than 1 nm error

# Create aliases for KLayout Python API methods:
Box = pya.Box
Point = pya.Point
Polygon = pya.Polygon
Text = pya.Text
Trans = pya.Trans
LayerInfo = pya.LayerInfo

###################################

#General Spiral Calculation Functions#
def frange(start,stop,step):
  #Used to define a float range, since python doesnt have a built in one
  x = start
  while x &lt;stop:
      yield x #returns value as generator, speeding up stuff
      x+=step
        
def angle_from_corrugation(r, length, grating_length):
    #Calculates the thetas at which the desired grating lengths are achieved. Outputs to an array    
    angle = 0
    current_length = 0
    x1=0
    y1=0
    current_total_length=0
    yield angle#yield acts as a return but gives a generator. This early yield is to return the 0 value
    
    while current_total_length &lt; length+grating_length: #The spiral gen doesnt draw the last grating because it needs to calculate slope, thus we draw an extra
        while current_length &lt; grating_length: #if the length has no reached the grating length, continue
            deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha)    
            r_spiral = (r*sign(angle))+(gap*angle/pi)
            S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX
            x2 = S.real
            y2= S.imag
            
            angle += angle_stepsize #continue to increase step size
            current_length = math.sqrt((x2-x1)**2+(y2-y1)**2) #figureout of the distance betweenthe two points
        #print("currentLength"+str(current_length))
        #print("targetlength"+str(grating_length))
        yield angle
        x1=S.real
        y1=S.imag
        current_total_length +=current_length
        current_length=0
        
def spiral_gen(r,angle_array,w,cwidth,grating_length):
    #This generates the spirals coordinates from the given angle arrays. Given there is a cwidth
    
    for i in frange(0,len(angle_array)-1,1):
      angle=angle_array[i]
      angle_next=angle_array[i+1]
      
      #Calculate Slope to ensure the gratings are 90 degree with the center guide line, note that the final point will be ignored here and appeneded later
      deltaX = (r*sign(angle_next))*cmath.exp(-abs(angle_next)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #Second Point
      r_spiral = (r*sign(angle_next))+(gap*angle_next/pi)
      S = (r_spiral*cmath.exp(j*abs(angle_next)))-deltaX    
      x2 = S.real
      y2 = S.imag
      deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #First Point
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX 
      x1 = S.real
      y1 = S.imag 
      #Slope
      if (grating_length != 0):
        dx = (x2-x1)/grating_length
        dy = (y2-y1)/grating_length
      else:
        print ("Grating_Length is 0, use legacy function")

      #Calculate the Coordinate for each grating and apply the slope modifer  
      #Outer, C1
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX    
      xcoor_Winc1 = S.real+dy*(w+cwidth)
      ycoor_Winc1 = S.imag-dx*(w+cwidth)     
      #Outer C2
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc2 = S.real+dy*(w-cwidth)
      ycoor_Winc2 = S.imag-dx*(w-cwidth)
      #Inner, C1
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc3 = S.real-dy*(w-cwidth)
      ycoor_Winc3 = S.imag+dx*(w-cwidth)
      #Inner C2

      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc4 = S.real-dy*(w+cwidth)
      ycoor_Winc4 = S.imag+dx*(w+cwidth)
      
      if cwidth!=0:  
        yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc2,ycoor_Winc2,xcoor_Winc3,ycoor_Winc3,xcoor_Winc4,ycoor_Winc4,dx,dy
      else:
        yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc3,ycoor_Winc3,dx,dy
                        
    
def sort_coord(bool_order,xinc,yinc,xdec,ydec):
    #this organizes the two sets of coordinates for each wall into an order to create gratings
    #can pass bool_order to decide which gets drawn first
    x_array=[]
    y_array=[]
    
    for i in range(len(xinc)):
        if bool_order == True:
            x_array.append(xdec[i])
            x_array.append(xinc[i])
            y_array.append(ydec[i])
            y_array.append(yinc[i])
            bool_order = not bool_order
        else:
            x_array.append(xinc[i])
            x_array.append(xdec[i])
            y_array.append(yinc[i])
            y_array.append(ydec[i])
            bool_order = not bool_order
    return x_array,y_array            
       
def finish_spiral(r,finalangle,w,dx,dy):
    #This finishes the spiral to the 0 or 180 position with a uniform waveguide, also makes it easier to match via pins
    #The radius of the individual walls, basically draws 2 lines for each wall of the waveguide and appends hte points
    r_Winc = r+w
    r_Wdec = r-w
    
    x_inc=[]
    y_inc=[]
    x_dec=[]
    y_dec=[]
    
    deltaX = (r*sign(finalangle))*cmath.exp(-abs(finalangle)/alpha)    
    r_spiral = (r*sign(finalangle))+(gap*finalangle/pi)
    S = (r_spiral*cmath.exp(j*abs(finalangle)))-deltaX  
    x_inc.append(S.real+dy*w)
    y_inc.append(S.imag-dx*w)
        
    r_spiral = (r*sign(finalangle))+(gap*finalangle/pi)
    S = (r_spiral*cmath.exp(j*abs(finalangle)))-deltaX  
    x_dec.append(S.real-dy*w)
    y_dec.append(S.imag+dx*w)

    nextpie = math.ceil(finalangle/ (pi)) * pi        
    for angle in frange(finalangle+0.01,nextpie,0.01):
        deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha)
        
        r_spiral = (r_Winc*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX  
        x_inc.append(S.real)
        y_inc.append(S.imag)
        
        r_spiral = (r_Wdec*sign(angle))+(gap*angle/pi)
        S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX  
        x_dec.append(S.real)
        y_dec.append(S.imag)
        
    #appends the final coordinate at y=0
    deltaX = (r*sign(nextpie))*cmath.exp(-abs(nextpie)/alpha)
    r_spiral = (r_Winc*sign(nextpie))+(gap*nextpie/pi)
    S = (r_spiral*cmath.exp(j*abs(nextpie)))-deltaX 
    x_inc.append(S.real)
    y_inc.append(S.imag)
    
    deltaX = (r*sign(nextpie))*cmath.exp(-abs(nextpie)/alpha)
    r_spiral = (r_Wdec*sign(nextpie))+(gap*nextpie/pi)
    S = (r_spiral*cmath.exp(j*abs(nextpie)))-deltaX 
    x_dec.append(S.real)
    y_dec.append(S.imag)

    #deltaX = (r*sign(nextpie))*cmath.exp(-abs(nextpie)/alpha)
    #r_spiral = (r*sign(nextpie))+(gap*nextpie/pi)
    #S = (r_spiral*cmath.exp(j*abs(nextpie)))-deltaX 
    #endx = S.real

    #if math.ceil(nextpie/pi) %2 ==0:
      #isEven = True
      #print ("even")
      #print (nextpie)
      #print (math.ceil(nextpie/pi) %2)
    #else:
      #isEven = False
      #print ("odd")
      #print (nextpie)
      #print (math.ceil(nextpie/pi) %2)
    
    return x_inc,y_inc,x_dec,y_dec#,endx,isEven
    
def spiral_gen_NoCenter(r,angle_array,w,cwidth,grating_length):
    #This generates the spirals coordinates from the given angle arrays. Given there is a cwidth
    #for i in frange(0,len(angle_array)-1,1):
    i = 0
    angle = 0
    xc1 = []
    xc2 = []
    yc1 = []
    yc2 = []

    while (angle&lt;pi):
      angle=angle_array[i]
      angle_next=angle_array[i+1]
      
      #Calculate Slope to ensure the gratings are 90 degree with the center guide line, note that the final point will be ignored here and appeneded later
      deltaX = (r*sign(angle_next))*cmath.exp(-abs(angle_next)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #Second Point
      r_spiral = (r*sign(angle_next))+(gap*angle_next/pi)
      S = (r_spiral*cmath.exp(j*abs(angle_next)))-deltaX    
      x2 = S.real
      y2 = S.imag
      deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #First Point
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX 
      x1 = S.real
      y1 = S.imag 
      #Slope
      if (grating_length != 0):
        dx = (x2-x1)/grating_length
        dy = (y2-y1)/grating_length
      else:
        print ("Grating_Length is 0, use legacy function")
      #Calculate the Coordinate for each grating and apply the slope modifer  
      #Outer, C1
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX    
      xc1.append(S.real+dy*(w))
      yc1.append(S.imag-dx*(w))
      #Inner, C1
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xc2.append(S.real-dy*(w))
      yc2.append(S.imag+dx*(w))
      i+=1
      
    return xc1,yc1,xc2,yc2,i
    
def spiral_gen_NoCenter_Gratings(r,angle_array,w,cwidth,grating_length,lasti):
    #This generates the spirals coordinates from the given angle arrays. Given there is a cwidth
    
    for i in frange(lasti,len(angle_array)-1,1):
      angle=angle_array[i]
      angle_next=angle_array[i+1]
      
      #Calculate Slope to ensure the gratings are 90 degree with the center guide line, note that the final point will be ignored here and appeneded later
      deltaX = (r*sign(angle_next))*cmath.exp(-abs(angle_next)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #Second Point
      r_spiral = (r*sign(angle_next))+(gap*angle_next/pi)
      S = (r_spiral*cmath.exp(j*abs(angle_next)))-deltaX    
      x2 = S.real
      y2 = S.imag
      deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha) #r, not r_inc here because then it will all end at 0,0     
      #First Point
      r_spiral = (r*sign(angle))+(gap*angle/pi)
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX 
      x1 = S.real
      y1 = S.imag 
      #Slope
      if (grating_length != 0):
        dx = (x2-x1)/grating_length
        dy = (y2-y1)/grating_length
      else:
        print ("Grating_Length is 0, use legacy function")

      #Calculate the Coordinate for each grating and apply the slope modifer  
      #Outer, C1
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX    
      xcoor_Winc1 = S.real+dy*(w+cwidth)
      ycoor_Winc1 = S.imag-dx*(w+cwidth)     
      #Outer C2
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc2 = S.real+dy*(w-cwidth)
      ycoor_Winc2 = S.imag-dx*(w-cwidth)
      #Inner, C1
      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc3 = S.real-dy*(w-cwidth)
      ycoor_Winc3 = S.imag+dx*(w-cwidth)
      #Inner C2

      S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX                 
      xcoor_Winc4 = S.real-dy*(w+cwidth)
      ycoor_Winc4 = S.imag+dx*(w+cwidth)
      
      if cwidth!=0:  
        yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc2,ycoor_Winc2,xcoor_Winc3,ycoor_Winc3,xcoor_Winc4,ycoor_Winc4,dx,dy
      else:
        yield xcoor_Winc1,ycoor_Winc1,xcoor_Winc3,ycoor_Winc3,dx,dy  
        
def angle_from_corrugation_NoCenter(r, length, grating_length):
    #Calculates the thetas at which the desired grating lengths are achieved. Outputs to an array    
    angle = 0
    current_length = 0
    x1=0
    y1=0
    current_total_length=0
    
    ##
    length *= 2 #length needs to be double since all gratings on one side
    ##
    
    yield angle#yield acts as a return but gives a generator. This early yield is to return the 0 value
    
    while current_total_length &lt; length+grating_length: #The spiral gen doesnt draw the last grating because it needs to calculate slope, thus we draw an extra
        while current_length &lt; grating_length: #if the length has no reached the grating length, continue
            deltaX = (r*sign(angle))*cmath.exp(-abs(angle)/alpha)    
            r_spiral = (r*sign(angle))+(gap*angle/pi)
            S = (r_spiral*cmath.exp(j*abs(angle)))-deltaX
            x2 = S.real
            y2= S.imag
            
            angle += angle_stepsize #continue to increase step size
            current_length = math.sqrt((x2-x1)**2+(y2-y1)**2) #figureout of the distance betweenthe two points
        #print("currentLength"+str(current_length))
        #print("targetlength"+str(grating_length))
        yield angle
        x1=S.real
        y1=S.imag
        if angle &gt; pi:
          current_total_length +=current_length
        current_length=0
                
###########################

class PCMSpiralBraggGrating(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(PCMSpiralBraggGrating, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')
    
    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Waveguide'])
    self.param("w", self.TypeDouble, "Waveguide Width [nm]", default = 400)
    self.param("DeviceLength", self.TypeDouble, "Device Path Length [mm]", default = 0.5)
    self.param("Cwidth", self.TypeDouble, "Corrugation Width [nm]", default = 80)
    self.param("period", self.TypeDouble, "period [nm]", default = 420 ) 
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "SpiralBraggGrating"

  def can_create_from_shape_impl(self):
    return False   
  
  def produce_impl(self):
    from SiEPIC._globals import PIN_LENGTH
    # This is the main part of the implementation: create the layout
    
    # fetch the parameters
    #self.w = 400
    #self.Length = 0.5
    #self.Cwidth = 80
    #self.pitch = 420
    #self.Chirp_Rate = 0
    #self.n = 1800
    
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)
    
    w = self.w*10**-3/2.0 #drawing from center line, only have to add half
    length = self.DeviceLength*1000/2.0#only drawing half and then copying
    cwidth = self.Cwidth*10**-3/2.0 #same reason as width
    grating_length = self.period/2.0*10**-3
     
    #Step1 Find the Angles of each grating#######    
    angle_array=[]
    for theta in angle_from_corrugation(r,length,grating_length):
        angle_array.append(theta)
    ####################
    
    #####################
    #Step2 Find the Coordinates of the gratings via the angles
    #Wall1 of the Left    
    left_x_inc = []
    left_y_inc = []
    left_x_dec = []
    left_y_dec = []
    #Wall2 of the Left
    left2_x_inc = []
    left2_y_inc = []
    left2_x_dec = []
    left2_y_dec = []
    
    #Calculate the Spiral Coordinates
    for coord in spiral_gen(r,angle_array,w,cwidth,grating_length):
        left_x_inc.append(coord[0])
        left_y_inc.append(coord[1])
        left_x_dec.append(coord[2])
        left_y_dec.append(coord[3])
        
        left2_x_inc.append(coord[4])
        left2_y_inc.append(coord[5])
        left2_x_dec.append(coord[6])
        left2_y_dec.append(coord[7])
    dx = coord[8]
    dy = coord[9]
    #Flip coords for right side coords
    right_x_inc = [i*-1 for i in left_x_inc]
    right_y_inc = [i*-1 for i in left_y_inc]
    right_x_dec = [i*-1 for i in left_x_dec]
    right_y_dec = [i*-1 for i in left_y_dec]
    
    right2_x_inc = [i*-1 for i in left2_x_inc]
    right2_y_inc = [i*-1 for i in left2_y_inc]
    right2_x_dec = [i*-1 for i in left2_x_dec]
    right2_y_dec = [i*-1 for i in left2_y_dec]
    #Obtain a sorted list of the coordinates of one wall.
    #repeat for the rest
    result = sort_coord(True,left_x_inc,left_y_inc,left_x_dec,left_y_dec)
    left1x = result[0]
    left1y = result[1]
    result = sort_coord(False,left2_x_inc,left2_y_inc,left2_x_dec,left2_y_dec)
    left2x = result[0]
    left2y = result[1]
    
    result = sort_coord(False,right_x_inc,right_y_inc,right_x_dec,right_y_dec)
    right1x = result[0]
    right1y = result[1]
    #Delete the first two points as they over lap
    del right1x[0]#calls the same index here because once you remove 0, 1 becomes 0, and so on and so forth
    del right1x[0]
    del right1y[0]
    del right1y[0]
    
    result = sort_coord(True,right2_x_inc,right2_y_inc,right2_x_dec,right2_y_dec)
    right2x = result[0]
    right2y = result[1]
    del right2x[0]
    del right2x[0]
    del right2y[0]
    del right2y[0]
    
    #UNIFORM SECTION
    
    del left1x[-1]
    del left1y[-1]
    del left2x[-1]
    del left2y[-1]

    del right1x[-1]
    del right1y[-1]
    del right2x[-1]
    del right2y[-1]
 
    result = finish_spiral(r,angle_array[-2],w,dx,dy)
    left1x.extend(result[0])
    left1y.extend(result[1])
    left2x.extend(result[2])
    left2y.extend(result[3])
    
    right1x.extend(i*-1 for i in result[0])
    right1y.extend(i*-1 for i in result[1])
    right2x.extend(i*-1 for i in result[2])
    right2y.extend(i*-1 for i in result[3])
    #########################################
    
    #Step3 Organize all the points into a single matrix to be drawn in klayout.
    spiral_x = []
    spiral_y = []
    
    spiral_x.extend(reversed(left1x))
    spiral_x.extend(right2x)
    spiral_x.extend(reversed(right1x))
    spiral_x.extend(left2x)
    
    spiral_y.extend(reversed(left1y))
    spiral_y.extend(right2y)
    spiral_y.extend(reversed(right1y))
    spiral_y.extend(left2y)
    
    #makes Dpoints from the coordinates
    dpts=[pya.DPoint(spiral_x[i], spiral_y[i]) for i in range(len(spiral_x))]
    dpolygon = DPolygon(dpts)    
    #dmult_pts = mult_pts(dpts,1)
        
    #dpoint polygon solution thanks to Jaspreet#
    element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    shapes(LayerSiN).insert(element)
    #shapes(LayerSiN).insert(Polygon.from_dpoly(dpolygon))      
    
    # Create the pins, as short paths:
    DeviceHeight = self.cell.bbox().height()*dbu
    
    #WG1
    wvg = pya.Path([Point((self.cell.bbox().width()/2.0)-w/dbu, 0),Point((self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/dbu/2.0)], w/dbu*2.0)
    shapes(LayerSiN).insert(wvg)
    #WG2
    wvg = pya.Path([Point(-(self.cell.bbox().width()/2.0)+w/dbu, 0),Point(-(self.cell.bbox().width()/2.0)+w/dbu, -DeviceHeight/dbu/2.0)], w/dbu*2.0)
    shapes(LayerSiN).insert(wvg)
    #pin1
    pin = pya.Path([Point(-(self.cell.bbox().width()/2.0)+w/dbu, -DeviceHeight/2.0/dbu+PIN_LENGTH/2.0), Point(-(self.cell.bbox().width()/2.0)+w/dbu,-DeviceHeight/2.0/dbu-PIN_LENGTH/2.0)], w/dbu*2.0)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,-(self.cell.bbox().width()/2.0)+w/dbu, -DeviceHeight/2.0/dbu)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    #pin2
    pin = pya.Path([Point((self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/2.0/dbu-PIN_LENGTH/2.0), Point((self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/2.0/dbu+PIN_LENGTH/2.0)], w/dbu*2.0)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,(self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/2.0/dbu)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
        
    # Create the device recognition layer
    #I literally declared the size of this box based on the other box. Lol.
    dev = Box(-self.cell.bbox().width()/2.0,-self.cell.bbox().height()/2.0+PIN_LENGTH/2.0,self.cell.bbox().width()/2.0,self.cell.bbox().height()/2.0-PIN_LENGTH/2.0)
    shapes(LayerDevRecN).insert(dev)

          
    print("Done drawing the layout for - PCM Spiral")

class PCMSpiralBraggGratingSlab(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(PCMSpiralBraggGratingSlab, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Waveguide'])
    self.param("w", self.TypeDouble, "Waveguide Width [nm]", default = 400)
    self.param("DeviceLength", self.TypeDouble, "Device Path Length [mm]", default = 0.5)
    self.param("Cwidth", self.TypeDouble, "Corrugation Width [nm]", default = 80)
    self.param("period", self.TypeDouble, "period [nm]", default = 420 ) 
    self.param("silayer2", self.TypeLayer, "Slab Si Layer", default = LayerInfo(31, 0))
    self.param("sw", self.TypeDouble, "Slab Width [nm]", default = 500 )
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "SpiralBraggGratingSlab"

  def can_create_from_shape_impl(self):
    return False   
  
  def produce_impl(self):
    from SiEPIC._globals import PIN_LENGTH
    
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)
    LayerSiN_Slab = ly.layer(self.silayer2)
    
    w = self.w*10**-3/2.0 #drawing from center line, only have to add half
    length = self.DeviceLength*1000/2.0#only drawing half and then copying
    cwidth = self.Cwidth*10**-3/2.0 #same reason as width
    grating_length = self.period/2.0*10**-3
    sw = self.sw*10**-3/2.0
     
    #Step1 Find the Angles of each grating#######    
    angle_array=[]
    for theta in angle_from_corrugation(r,length,grating_length):
        angle_array.append(theta)
    ####################
    
    #####################
    #Step2 Find the Coordinates of the gratings via the angles
    #Wall1 of the Left    
    left_x_inc = []
    left_y_inc = []
    left_x_dec = []
    left_y_dec = []
    #Wall2 of the Left
    left2_x_inc = []
    left2_y_inc = []
    left2_x_dec = []
    left2_y_dec = []
    
    #Calculate the Spiral Coordinates
    for coord in spiral_gen(r,angle_array,w,cwidth,grating_length):
        left_x_inc.append(coord[0])
        left_y_inc.append(coord[1])
        left_x_dec.append(coord[2])
        left_y_dec.append(coord[3])
        
        left2_x_inc.append(coord[4])
        left2_y_inc.append(coord[5])
        left2_x_dec.append(coord[6])
        left2_y_dec.append(coord[7])
    dx = coord[8]
    dy = coord[9]
    #Flip coords for right side coords
    right_x_inc = [i*-1 for i in left_x_inc]
    right_y_inc = [i*-1 for i in left_y_inc]
    right_x_dec = [i*-1 for i in left_x_dec]
    right_y_dec = [i*-1 for i in left_y_dec]
    
    right2_x_inc = [i*-1 for i in left2_x_inc]
    right2_y_inc = [i*-1 for i in left2_y_inc]
    right2_x_dec = [i*-1 for i in left2_x_dec]
    right2_y_dec = [i*-1 for i in left2_y_dec]
    #Obtain a sorted list of the coordinates of one wall.
    #repeat for the rest
    result = sort_coord(True,left_x_inc,left_y_inc,left_x_dec,left_y_dec)
    left1x = result[0]
    left1y = result[1]
    result = sort_coord(False,left2_x_inc,left2_y_inc,left2_x_dec,left2_y_dec)
    left2x = result[0]
    left2y = result[1]
    
    result = sort_coord(False,right_x_inc,right_y_inc,right_x_dec,right_y_dec)
    right1x = result[0]
    right1y = result[1]
    #Delete the first two points as they over lap
    del right1x[0]#calls the same index here because once you remove 0, 1 becomes 0, and so on and so forth
    del right1x[0]
    del right1y[0]
    del right1y[0]
    
    result = sort_coord(True,right2_x_inc,right2_y_inc,right2_x_dec,right2_y_dec)
    right2x = result[0]
    right2y = result[1]
    del right2x[0]
    del right2x[0]
    del right2y[0]
    del right2y[0]
    
    #UNIFORM SECTION
    
    del left1x[-1]
    del left1y[-1]
    del left2x[-1]
    del left2y[-1]

    del right1x[-1]
    del right1y[-1]
    del right2x[-1]
    del right2y[-1]
 
    result = finish_spiral(r,angle_array[-2],w,dx,dy)
    left1x.extend(result[0])
    left1y.extend(result[1])
    left2x.extend(result[2])
    left2y.extend(result[3])
    
    right1x.extend(i*-1 for i in result[0])
    right1y.extend(i*-1 for i in result[1])
    right2x.extend(i*-1 for i in result[2])
    right2y.extend(i*-1 for i in result[3])
    #########################################
    
    #Step3 Organize all the points into a single matrix to be drawn in klayout.
    spiral_x = []
    spiral_y = []
    
    spiral_x.extend(reversed(left1x))
    spiral_x.extend(right2x)
    spiral_x.extend(reversed(right1x))
    spiral_x.extend(left2x)
    
    spiral_y.extend(reversed(left1y))
    spiral_y.extend(right2y)
    spiral_y.extend(reversed(right1y))
    spiral_y.extend(left2y)
    
    #makes Dpoints from the coordinates
    dpts=[pya.DPoint(spiral_x[i], spiral_y[i]) for i in range(len(spiral_x))]
    dpolygon = DPolygon(dpts)    
    #dmult_pts = mult_pts(dpts,1)
        
    #dpoint polygon solution thanks to Jaspreet#
    element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    shapes(LayerSiN).insert(element)
    
    #Step4 Draw slab spiral
    #Step2 Find the Coordinates of the gratings via the angles
    #Wall1 of the Left    
    left_xS = []
    left_yS = []
    #Wall2 of the Left
    left2_xS = []
    left2_yS = []
    
    #Calculate the Spiral Coordinates
    for coord in spiral_gen(r,angle_array,sw,0,grating_length):
    #for coord in spiral_gen_legacy(r,angle_array,sw):
        left_xS.append(coord[0])
        left_yS.append(coord[1])
        left2_xS.append(coord[2])
        left2_yS.append(coord[3])
        
    #Flip coords for right side coords
    right_xS = [i*-1 for i in left_xS]
    right_yS = [i*-1 for i in left_yS]    
    right2_xS = [i*-1 for i in left2_xS]
    right2_yS = [i*-1 for i in left2_yS]
    #Obtain a sorted list of the coordinates of one wall.
    
    #Delete the first two points as they over lap
    del right_xS[0]#calls the same index here because once you remove 0, 1 becomes 0, and so on and so forth
    del right_xS[0]
    del right_yS[0]
    del right_yS[0]
    
    del right2_xS[0]
    del right2_xS[0]
    del right2_yS[0]
    del right2_yS[0]
    
    #UNIFORM SECTION
    del left_xS[-1]
    del left_yS[-1]
    del left2_xS[-1]
    del left2_yS[-1]
    
    del right_xS[-1]
    del right_yS[-1]
    del right2_xS[-1]
    del right2_yS[-1]
     
    result = finish_spiral(r,angle_array[-1],sw,1,1)
    left_xS.extend(result[0])
    left_yS.extend(result[1])
    left2_xS.extend(result[2])
    left2_yS.extend(result[3])
    
    right_xS.extend(i*-1 for i in result[0])
    right_yS.extend(i*-1 for i in result[1])
    right2_xS.extend(i*-1 for i in result[2])
    right2_yS.extend(i*-1 for i in result[3])
    #########################################
    
    #Step4.5 Organize all the points into a single matrix to be drawn in klayout.
    slab_x = []
    slab_y = []
    
    slab_x.extend(reversed(left_xS))
    slab_x.extend(right2_xS)
    slab_x.extend(reversed(right_xS))
    slab_x.extend(left2_xS)
    
    slab_y.extend(reversed(left_yS))
    slab_y.extend(right2_yS)
    slab_y.extend(reversed(right_yS))
    slab_y.extend(left2_yS)
    
    #makes Dpoints from the coordinates
    dptsS=[pya.DPoint(slab_x[i], slab_y[i]) for i in range(len(slab_x))]
    dpolygonS = DPolygon(dptsS)    
    #dmult_pts = mult_pts(dpts,1)
        

    #Step6 Pins!    
    DeviceWidthNS = self.cell.bbox().width() #width of device without slab included yet, for drawing WG
    
    #insert slab
    #dpoint polygon solution thanks to Jaspreet#
    elementS = Polygon.from_dpoly(dpolygonS*(1.0/dbu))
    shapes(LayerSiN_Slab).insert(elementS)
    #Slab Tapers
    dpts=[pya.DPoint(-(self.cell.bbox().width()/2.0*dbu), 0),pya.DPoint(-(self.cell.bbox().width()/2.0)*dbu+sw*2.0, 0),pya.DPoint(-(self.cell.bbox().width()/2.0)*dbu+(sw-w)+w*2.0, -10),pya.DPoint(-(self.cell.bbox().width()/2.0)*dbu+(sw-w), -10)]
    dpolygon = DPolygon(dpts)
    element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    shapes(LayerSiN_Slab).insert(element)
    dpts=[pya.DPoint((self.cell.bbox().width()/2.0*dbu), 0),pya.DPoint((self.cell.bbox().width()/2.0)*dbu-sw*2.0, 0),pya.DPoint((self.cell.bbox().width()/2.0)*dbu-(sw-w)-w*2.0, +10),pya.DPoint((self.cell.bbox().width()/2.0)*dbu-(sw-w), +10)]
    dpolygon = DPolygon(dpts)
    element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    shapes(LayerSiN_Slab).insert(element)

    DeviceHeight = self.cell.bbox().height()*dbu
    #WG1
    wvg = pya.Path([Point((DeviceWidthNS/2.0)-w/dbu, 0),Point((DeviceWidthNS/2.0)-w/dbu, DeviceHeight/dbu/2.0)], w/dbu*2.0)
    shapes(LayerSiN).insert(wvg)  
    #WG2
    wvg = pya.Path([Point((-DeviceWidthNS/2.0)+w/dbu, 0),Point((-DeviceWidthNS/2.0)+w/dbu, -DeviceHeight/dbu/2.0)], w/dbu*2.0)
    shapes(LayerSiN).insert(wvg)
    #Pin1
    pin = pya.Path([Point((-DeviceWidthNS/2.0)+w/dbu, -DeviceHeight/2.0/dbu+PIN_LENGTH/2.0), Point((-DeviceWidthNS/2.0)+w/dbu,-DeviceHeight/2.0/dbu-PIN_LENGTH/2.0)], w/dbu*2.0)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,-(DeviceWidthNS/2.0)+w/dbu, -DeviceHeight/2.0/dbu)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    #Pin2
    pin = pya.Path([Point((DeviceWidthNS/2.0)-w/dbu, DeviceHeight/2.0/dbu-PIN_LENGTH/2.0), Point((DeviceWidthNS/2.0)-w/dbu, DeviceHeight/2.0/dbu+PIN_LENGTH/2.0)], w/dbu*2.0)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,(DeviceWidthNS/2.0)-w/dbu, DeviceHeight/2.0/dbu)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
     
    # Create the device recognition layer
    #I literally declared the size of this box based on the other box. Lol.
    dev = Box(-self.cell.bbox().width()/2.0,-self.cell.bbox().height()/2.0+PIN_LENGTH/2.0,self.cell.bbox().width()/2.0,self.cell.bbox().height()/2.0-PIN_LENGTH/2.0)
    shapes(LayerDevRecN).insert(dev)
    
    print("Done drawing the layout for - PCM Spiral with Slabs")
       
class Spiral_NoCenterBraggGrating(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(Spiral_NoCenterBraggGrating, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Waveguide'])
    self.param("w", self.TypeDouble, "Waveguide Width [nm]", default = 400)
    self.param("DeviceLength", self.TypeDouble, "Device Path Length [mm]", default = 0.5)
    self.param("Cwidth", self.TypeDouble, "Corrugation Width [nm]", default = 80)
    self.param("period", self.TypeDouble, "period [nm]", default = 420 ) 
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "SpiralBraggGrating"

  def can_create_from_shape_impl(self):
    return False   
  
  def produce_impl(self):
    # This is the main part of the implementation: create the layout
    from SiEPIC._globals import PIN_LENGTH

    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)
    
    w = self.w*10**-3/2.0 #drawing from center line, only have to add half
    length = self.DeviceLength*1000/2.0#only drawing half and then copying
    cwidth = self.Cwidth*10**-3/2.0 #same reason as width
    grating_length = self.period/2.0*10**-3
     
    #Step1 Find the Angles of each grating#######    
    angle_array=[]
    for theta in angle_from_corrugation(r,length,grating_length):
        angle_array.append(theta)
    
    #IF WANT TO CALCULATE BASED ON LENGTH OF WG that includes gratings
    '''    
    angle_array_NoCenter=[]
    for theta in angle_from_corrugation_NoCenter(r,length,grating_length):
        angle_array_NoCenter.append(theta)
    '''
    ####################
    
    #####################
    #Step2 Find the Coordinates of the gratings via the angles
    #Wall1 of the Left    
    left_x_inc = []
    left_y_inc = []
    left_x_dec = []
    left_y_dec = []
    #Wall2 of the Left
    left2_x_inc = []
    left2_y_inc = []
    left2_x_dec = []
    left2_y_dec = []
    
    
    nongrating = spiral_gen_NoCenter(r,angle_array,w,cwidth,grating_length)
    left1c_x = nongrating[0]
    left1c_y = nongrating[1]
    left2c_x = nongrating[2]
    left2c_y = nongrating[3]
    lasti = nongrating[4]
    right1c_x = [i*-1 for i in left1c_x]
    right1c_y = [i*-1 for i in left1c_y]
    right2c_x = [i*-1 for i in left2c_x]
    right2c_y = [i*-1 for i in left2c_y]
    
    #Calculate the Spiral Coordinates
    #IF WANT TO CALCULATE BASED ON LENGTH OF WG that includes gratings
    #for coord in spiral_gen_NoCenter_Gratings(r,angle_array_NoCenter,w,cwidth,grating_length,lasti-1):
    for coord in spiral_gen_NoCenter_Gratings(r,angle_array,w,cwidth,grating_length,lasti-1):
        left_x_inc.append(coord[0])
        left_y_inc.append(coord[1])
        left_x_dec.append(coord[2])
        left_y_dec.append(coord[3])
        
        left2_x_inc.append(coord[4])
        left2_y_inc.append(coord[5])
        left2_x_dec.append(coord[6])
        left2_y_dec.append(coord[7])
    
    dx = coord[8]
    dy = coord[9]
    
    right1x =[]
    right1y =[]
    right2x =[]
    right2y =[]
    for coord in spiral_gen_NoCenter_Gratings(r,angle_array,w,0,grating_length,lasti-1):
      right1x.append(coord[0])
      right1y.append(coord[1])
      right2x.append(coord[2])
      right2y.append(coord[3])

    #Flip coords for right side coords
    right1x = [i*-1 for i in right1x]
    right1y = [i*-1 for i in right1y]
    right2x = [i*-1 for i in right2x]
    right2y = [i*-1 for i in right2y]

    #Obtain a sorted list of the coordinates of one wall.
    #repeat for the rest
    result = sort_coord(True,left_x_inc,left_y_inc,left_x_dec,left_y_dec)
    left1x = result[0]
    left1y = result[1]
    result = sort_coord(False,left2_x_inc,left2_y_inc,left2_x_dec,left2_y_dec)
    left2x = result[0]
    left2y = result[1]

    #Center Boundary Point
    del left1x[0]
    del left1y[0]
    del left2x[0]
    del left2y[0]
    
    #UNIFORM SECTION
    
    del left1x[-1]
    del left1y[-1]
    del left2x[-1]
    del left2y[-1]

    del right1x[-1]
    del right1y[-1]
    del right2x[-1]
    del right2y[-1]
 
    result = finish_spiral(r,angle_array[-2],w,dx,dy)
    #IF WANT TO CALCULATE BASED ON LENGTH OF WG that includes gratings
    #result = finish_spiral(r,angle_array_NoCenter[-2],w,dx,dy)
    left1x.extend(result[0])
    left1y.extend(result[1])
    left2x.extend(result[2])
    left2y.extend(result[3])
    
    right1x.extend(i*-1 for i in result[0])
    right1y.extend(i*-1 for i in result[1])
    right2x.extend(i*-1 for i in result[2])
    right2y.extend(i*-1 for i in result[3])
    #########################################
    
    #Step3 Organize all the points into a single matrix to be drawn in klayout.
    spiral_x = []
    spiral_y = []
    
    spiral_x.extend(reversed(left1x))
    spiral_x.extend(reversed(left1c_x))
    spiral_x.extend(right2c_x)
    spiral_x.extend(right2x)
    spiral_x.extend(reversed(right1x))
    spiral_x.extend(reversed(right1c_x))
    spiral_x.extend(left2c_x)
    spiral_x.extend(left2x)
    
    spiral_y.extend(reversed(left1y))
    spiral_y.extend(reversed(left1c_y))
    spiral_y.extend(right2c_y)
    spiral_y.extend(right2y)
    spiral_y.extend(reversed(right1y))
    spiral_y.extend(reversed(right1c_y))
    spiral_y.extend(left2c_y)
    spiral_y.extend(left2y)
    
    #makes Dpoints from the coordinates
    dpts=[pya.DPoint(spiral_x[i], spiral_y[i]) for i in range(len(spiral_x))]
    dpolygon = DPolygon(dpts)    
    #dmult_pts = mult_pts(dpts,1)
        
    #dpoint polygon solution thanks to Jaspreet#
    element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    shapes(LayerSiN).insert(element)
    #shapes(LayerSiN).insert(Polygon.from_dpoly(dpolygon))      
    
    # Create the pins, as short paths:
    #LendX = result[4]
    #RendX = -result[4]
    #isEven = result[5] #Left and Right sides swap depending on the circle drawn, this returns which side it should be on
    
    #if isEven == True:
      #DeviceHeight = self.cell.bbox().height()*dbu
      #MOD = 1 #Based on the side, modifies certain values that are just scalar additions below    
    #else:
      #DeviceHeight = -self.cell.bbox().height()*dbu
      #MOD = -1

    DeviceHeight = self.cell.bbox().height()*dbu
    #waveguides, didnt use pathing because it has some rounding errors in terms of width   
    #dpts=[pya.DPoint(LendX+w, 0),pya.DPoint(LendX-w, 0),pya.DPoint(LendX-w, DeviceHeight/2.0),pya.DPoint(LendX+w, DeviceHeight/2.0 )]
    #dpolygon = DPolygon(round(dpts))
    #element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    #shapes(LayerSiN).insert(element)
    
    wvg = pya.Path([Point((self.cell.bbox().width()/2.0)-w/dbu, 0),Point((self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/dbu/2.0)], w/dbu*2.0)
    shapes(LayerSiN).insert(wvg)
    
    #dpts=[pya.DPoint(RendX+w, 0),pya.DPoint(RendX-w, 0),pya.DPoint(RendX-w, -DeviceHeight/2.0),pya.DPoint(RendX+w, -DeviceHeight/2.0 )]
    #dpolygon = DPolygon(dpts)
    #element = Polygon.from_dpoly(dpolygon*(1.0/dbu))
    #shapes(LayerSiN).insert(element)

    wvg = pya.Path([Point(-(self.cell.bbox().width()/2.0)+w/dbu, 0),Point(-(self.cell.bbox().width()/2.0)+w/dbu, -DeviceHeight/dbu/2.0)], w/dbu*2.0)
    shapes(LayerSiN).insert(wvg)

    #pin = pya.Path([Point((RendX)/dbu*1.0, -DeviceHeight/2.0/dbu-PIN_LENGTH/2.0), Point((RendX)/dbu*1.0,-DeviceHeight/2.0/dbu+PIN_LENGTH/2.0)], w/dbu*2.0)
    pin = pya.Path([Point(-(self.cell.bbox().width()/2.0)+w/dbu, -DeviceHeight/2.0/dbu+PIN_LENGTH/2.0), Point(-(self.cell.bbox().width()/2.0)+w/dbu,-DeviceHeight/2.0/dbu-PIN_LENGTH/2.0)], w/dbu*2.0)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,-(self.cell.bbox().width()/2.0)+w/dbu, -DeviceHeight/2.0/dbu)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    #pin = pya.Path([Point((LendX)/dbu*1.0, DeviceHeight/2.0/dbu-PIN_LENGTH/2.0), Point((LendX)/dbu*1.0, DeviceHeight/2.0/dbu+PIN_LENGTH/2.0)], w/dbu*2.0)
    pin = pya.Path([Point((self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/2.0/dbu-PIN_LENGTH/2.0), Point((self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/2.0/dbu+PIN_LENGTH/2.0)], w/dbu*2.0)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,(self.cell.bbox().width()/2.0)-w/dbu, DeviceHeight/2.0/dbu)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    # Create the device recognition layer
    #dev = Box((LendX)/dbu+w*MOD/dbu, -DeviceHeight/2/dbu-pin_length/2, (RendX)/dbu-w*MOD/dbu, DeviceHeight/2/dbu+pin_length/2 )
    #I literally declared the size of this box based on the other box. Lol.
    dev = Box(-self.cell.bbox().width()/2.0,-self.cell.bbox().height()/2.0+PIN_LENGTH/2.0,self.cell.bbox().width()/2.0,self.cell.bbox().height()/2.0-PIN_LENGTH/2.0)
    shapes(LayerDevRecN).insert(dev)
          
    print("Done drawing the layout for - Spiral NoCenterBraggGrating")
    
class SiEPIC(pya.Library):
  """
  The library where we will put the PCell into 
  """

  def __init__(self):

    print("Initializing Adiabatic Spiral PCells library.")
  
    # Set the description
    self.description = "EBeam"
    
    # Create the PCell declarations
    self.layout().register_pcell("[1] Spiral_BraggGrating", PCMSpiralBraggGrating())
    self.layout().register_pcell("[2] Spiral_BraggGrating_Slab", PCMSpiralBraggGratingSlab())
    self.layout().register_pcell("[3] Spiral_NoCenterBraggGrating", Spiral_NoCenterBraggGrating())
    
    # Register us with the name "Adiabatic_Spirals".
    # If a library with that name already existed, it will be replaced then.
    self.register("Adiabatic_Spirals")
 
# Instantiate and register the library
SiEPIC()
</text>
</klayout-macro>
